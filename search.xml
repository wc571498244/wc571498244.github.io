<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack自吐</title>
      <link href="/2025/01/03/webpack-zi-tu/"/>
      <url>/2025/01/03/webpack-zi-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack自吐"><a href="#webpack自吐" class="headerlink" title="webpack自吐"></a>webpack自吐</h1><p>示例网站：aHR0cHM6Ly9zcGEyLnNjcmFwZS5jZW50ZXIv</p><p>示例接口：aHR0cHM6Ly9zcGEyLnNjcmFwZS5jZW50ZXIvYXBpL21vdmllLw==</p><p>token值js动态生成<img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/aa7e9062-d6a5-41f7-8a59-1d4a4fab75a1.png" alt="image.png"></p><p>根据接口的堆栈信息可定位到token生成代码</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/abca510c-9627-44ef-a786-96c4e1b687f0.png" alt="image.png"></p><p>进入到 Object(i[“a”]) 中，里面代码非常简单明了；直接扣算法最简单（代码如下）。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto-js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token string">'1735870406'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 时间戳</span><span class="token keyword">var</span> o <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">SHA1</span><span class="token punctuation">(</span><span class="token string">'/api/movie,20,1735870406'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>crypto<span class="token punctuation">.</span>enc<span class="token punctuation">.</span>Hex<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// url的path,offset,时间戳</span><span class="token keyword">var</span> c <span class="token operator">=</span> crypto<span class="token punctuation">.</span>enc<span class="token punctuation">.</span>Base64<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>crypto<span class="token punctuation">.</span>enc<span class="token punctuation">.</span>Utf8<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">[</span>o<span class="token punctuation">,</span> t<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/d6d34917-7b8f-40a1-a666-14f0760d7d0a.png" alt="image.png"></p><p>这里我们学习webpack自吐，因为token生成用到了n变量，而n在上面可以看到是r(‘3452’)生成的（webpack），断点到var n = r(“3452”); 刷新页面再根据堆栈信息定位到webpack加载器，从而把加载器抠出来。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/d631e730-cb65-4e78-969c-3b52fda1ae7f.png" alt="image.png"></p><p>定位到加载器，将app.e9fbf43f.js的代码扣出来，放在本地执行，解决完window的问题运行不报错即可。</p><p>接下来在加载器中 exports 后下个断点，重新刷新页面。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/2a49c881-3ca0-4f8c-8f52-65b9edfd967b.png" alt="image.png"></p><p>再将自吐代码放入控制台执行，代码如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c 是加载器。 上面可以识别出来</span>window<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        window<span class="token punctuation">.</span>res <span class="token operator">=</span> window<span class="token punctuation">.</span>res <span class="token operator">+</span> <span class="token template-string"><span class="token string">`"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"`</span></span> <span class="token operator">+</span> <span class="token string">":"</span><span class="token operator">+</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> window<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后，跳到下个断点（也就是在执行var n = r(“3452”); 之前）；将window.flag改为ture（按需获取）。</p><p>继续在i函数执行完后下个断点，也就是执行i函数所需要使用到的js文件。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/7fafde9b-f560-4255-878d-99c9b365d647.png" alt="image.png"></p><p>断点跳到i函数执行完，控制台输出window.res, 即可自动吐出3452所需要的js文件了。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/Pd6l2YRpW2oVO7Ma/img/878ed208-9dfc-45ff-bef6-3c4a57ce9871.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack逆向</title>
      <link href="/2024/12/27/webpack-ni-xiang/"/>
      <url>/2024/12/27/webpack-ni-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack扣代码"><a href="#webpack扣代码" class="headerlink" title="webpack扣代码"></a>webpack扣代码</h1><p>参考：<a href="https://app.yinxiang.com/fx/970ae39c-9964-4aae-aa96-7e81fee4ef8f" target="_blank" rel="noopener">https://app.yinxiang.com/fx/970ae39c-9964-4aae-aa96-7e81fee4ef8f</a></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>网址：aHR0cHM6Ly93d3cuY29pbmdsYXNzLmNvbS8=</p><p>接口：aHR0cHM6Ly9jYXBpLmNvaW5nbGFzcy5jb20vYXBpL2V0Zi9mbG93</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/39a24ad3-34f2-4ba9-9cb0-7a1c48106f96.png" alt="image.png"></p><ol><li>先定位接口以及返回的数据</li></ol><p>接口上面已给出，响应数据一看就有加密。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/052f6ff1-eece-4679-9d19-f09eaa2197c8.png" alt="image.png"></p><ol start="2"><li>使用XHR断点进行debugger</li></ol><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/71d5c3eb-2d51-42c5-a76f-97c1afd95ee6.png" alt="image.png"></p><p>一步一步调试，找到解密的关键代码</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/6460a5f6-c7fd-4e57-8864-eb1dd47bc7ce.png" alt="image.png"></p><ol start="3"><li>webpack打包</li></ol><p>通过debugger调试，把这个解密的js拉到开头，可以看出典型的webpack打包</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/ca78e79f-e7f9-4c80-94ff-1628641ffa8f.png" alt="image.png"></p><p>跟进到eZ里面去</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/b57d05ba-45ba-43fb-abbf-152cf8c0c88a.png" alt="image.png"></p><ol start="4"><li>找到webpack加载器</li></ol><p>这里需要跟进到加载器，将加载器扣出来。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/32c2a803-147b-453d-9f44-5bd96d36f136.png" alt="image.png"></p><p>根据堆栈信息，可以找到加载器的入口</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/58e32640-051b-49d3-848e-37da1fa54e86.png" alt="image.png"></p><p>将加载器复制出来，保存为本地js</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/11b01226-b678-4297-8944-0a4352e2d012.png" alt="image.png"></p><ol start="5"><li>调试webpack，扣对应使用的js文件，补环境。</li></ol><p>新建load.js, 将加载器全部复制出来</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/673b5c8e-cbd8-4b19-89a6-6052a750720e.png" alt="image.png"></p><p>通过加载器代码可发现h为加载器函数，使用全局变量导出 加载器函数。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/ca8f4045-fce1-4d39-bd1a-2ce881131a63.png" alt="image.png"></p><p>调试, 发现报错</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/485128a9-dc2a-4f80-b3be-f156a7e1b6f6.png" alt="image.png"></p><p>打断点到self这里，看下是什么。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/3e3eb1f1-5305-4c71-88f1-6eb5db894952.png" alt="image.png"></p><p>这里可发现self就是window。</p><p>直接补环境即可。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/bd2791bf-53d7-496b-ba8e-81e41af6ae2b.png" alt="image.png"></p><p>继续执行，发行正常运行。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/89960f16-4e75-42ad-868d-86a0f93d7aa4.png" alt="image.png"></p><p>接下来定位到解密的js，看到上面的 解密的关键代码 那块的图；找到对应的js文件和执行解密的代码块，看是使用的那个模块。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/094e0ce1-01be-4b64-b23e-690fcecd3f1b.png" alt="image.png"></p><p>定位到解密的关键代码块，往上找加载了什么模块。</p><p>我这里将这个js全部复制到vscode里面，通过关键字搜索，定位到了解密代码块，vscode也有提示这个代码块是属于那个模块的。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/dd9c3803-58c6-4599-9236-66141a96b642.png" alt="image.png"></p><p>可以看出来是2214模块</p><p>再使用加载器，调试下这个模块。</p><p>window.my_load(2214)</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/03009470-e513-4c32-8752-bc40aea0311f.png" alt="image.png"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/c7da9e71-c08b-4aba-a352-8c1f723f389e.png" alt="image.png"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/4c947fc2-51cd-4de2-928b-cd94b737faeb.png" alt="image.png"></p><p>通过输出结果，发现2214这个模块没有加载进来。</p><p>好，刚才我们已经定位到这个js了，直接全扣出来。</p><p>新建个文件 wp_model.js, 将那个js全部复制到文件中<img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/70ff3b1c-c591-4ac7-8266-512f853f7beb.png" alt="image.png"></p><p>再将该js导入到load.js里面，再次执行。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/4a746d69-e5bb-48a9-8882-33032ddb048e.png" alt="image.png"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/f0192eff-86e3-43c7-99d0-4b2d8b41c107.png" alt="image.png"></p><p>好，发现还缺少另一个模块 67294。</p><p>直接通过开发者工具搜索，67294:，找到对应的模块加载js，将其扣入wp_model.js中，再次执行load.js直到把所有使用到的模块补全。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/bdc5d5d8-2fa3-4094-80a9-e70aad16f8ec.png" alt="image.png"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/1115e733-d6df-4d48-9297-eca1a14bee3b.png" alt="image.png"></p><p>这个案例用到了这两个模块（其实我们扣多了，有更简化的方案，这里不赘述）；</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/eaf72524-c0f8-4a0e-a8b9-bb7d879a7a7a.png" alt="image.png"></p><p>直到输出没有报错，表示已经完成🎉。</p><ol start="6"><li>使用全局变量导出解密函数<br>前面我们已经找到了解密关键代码块对应的function，这里直接用全局变量给他导出。</li></ol><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/49e00760-5ba4-44ff-88eb-202939d42c9b.png" alt="image.png"></p><p>也就是这个function。</p><p>找到我们wp_model.js中对应的位置，使用window全局变量挂到自定义一个变量上去。即可使用。</p><p>比如window.my_decrypt = function(t) ….</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/be7a7203-a0c3-41bc-9c4d-d8d750c0177e.png" alt="image.png"></p><p>这里可以看到需要传入t参数，t参数怎么来呢？直接在浏览器上debugger到这里，复制t 这个obj就行。</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/70ea8b29-bbe2-417a-ae99-67d74e7e035a.png" alt="image.png"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4nyR1P5pWYqLbj/img/6ffe602d-1d5b-4c45-aeac-4c4ffe8b6761.png" alt="image.png"></p><p>至此恭喜你完成解密。🎉</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次OOM</title>
      <link href="/2023/03/13/ji-yi-ci-oom/"/>
      <url>/2023/03/13/ji-yi-ci-oom/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>最近报表解析告警群，频繁出现kafka堆积告警。<br>topic某个partition消费不动，其他partition消费正常，异常奇怪；同时消费者服务其中一个pod先挂掉，引发rebalance，导致其他pod也rebalance，同时挂掉；重启次数较多。</p><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li>本地解析该报表并没有复现该问题</li><li>拿到partition中提交的最近的offset，获取其消息内容；发现该消息内容中的报表数据比其他报表数据大十几倍；从而让运维同事增加pod的内存资源。512m -&gt; 2G，然并软。（由于腾讯云上pod重启只能看到事件，无法实施观察到对应的输出日志；ELK只收集json格式日志）</li><li>联系运维同事，将deployment中启运行命令改为 tial -f 某个文件，先让deployment挂起。再进入到对应的pod，启动消费者；程序运行几分钟之后就被kill掉</li></ol><h3 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h3><h4 id="排查被kill的源头。"><a href="#排查被kill的源头。" class="headerlink" title="排查被kill的源头。"></a>排查被kill的源头。</h4><p>由于使用的python的docker基础镜像，debian系统 /var/log/message（日志）并没有该文件。<br>使用 <code>strace</code> 工具：用于跟踪进程执行时的系统调用和所接收的信号，用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p><h4 id="安装-strace"><a href="#安装-strace" class="headerlink" title="安装 strace"></a>安装 strace</h4><pre class="line-numbers language-sh"><code class="language-sh">apt update -yapt install strace -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行 <code>strace -p PID</code> 命令，来追踪进程的系统调用蛛丝马迹。<br>显示结果如下：</p><pre class="line-numbers language-sh"><code class="language-sh">16:02:19.192409 mprotect(0x7f4aa886b000, 552960, PROT_READ|PROT_WRITE) = 0 <0.000014>16:02:19.744000 mmap(NULL, 552960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory) <0.000108>16:02:19.755545 mprotect(0x7f4aa88f2000, 552960, PROT_READ|PROT_WRITE) = 0 <0.000019>16:02:23.404805 mmap(NULL, 552960, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0 <ptrace(SYSCALL):No such process>16:02:25.325272 +++ killed by SIGKILL +++[1]+ Killed python will_be_killed.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KILLED信号对照表"><a href="#KILLED信号对照表" class="headerlink" title="KILLED信号对照表"></a>KILLED信号对照表</h4><pre><code>信号 　　　值 处理动作 发出信号的原因 ---------------------------------------------------------------------- SIGHUP　　1 　　A　　 终端挂起或者控制进程终止 SIGINT 　　2 　　A 　　键盘中断（如break键被按下） SIGQUIT 　 3 　　C 　　键盘的退出键被按下 SIGILL 　　 4 　　C 　　非法指令 SIGABRT 　6 　　C 　　由abort(3)发出的退出指令 SIGFPE 　  8 　　C 　　浮点异常 SIGKILL 　9 　　AEF　　Kill信号 SIGSEGV   11 　　C　　无效的内存引用 SIGPIPE 　13 　　A　　管道破裂: 写一个没有读端口的管道 SIGALRM 14 　　 A　　由alarm(2)发出的信号 SIGTERM 15 　　 A　　终止信号 SIGUSR1  30,10,16 A 　用户自定义信号1 SIGUSR2  31,12,17 A 　用户自定义信号2 SIGCHLD  20,17,18 B    子进程结束信号 SIGCONT  19,18,25       进程继续（曾被停止的进程） SIGSTOP  17,19,23 DEF 终止进程 SIGTSTP  18,20,24 D 控制终端（tty）上按下停止键 SIGTTIN   21,21,26 D 后台进程企图从控制终端读 SIGTTOU 22,22,27 D 后台进程企图从控制终端写 </code></pre><p>从结果可以看出该程序是被强制KILL了。</p><p>debian系统中，可以通过dmesg查看：<br><code>dmesg －T | grep -E -i -B100 &#39;killed process&#39;</code></p><p>输出结果：</p><pre><code>[月 12日 24 16:02:24 2022] [ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name[月 12日 24 16:02:24 2022] [ 172] 0 172 10553 722 23 1375 0 systemd-journal[月 12日 24 16:02:24 2022] [ 181] 0 181 10201 398 22 134 -1000 systemd-udevd[月 12日 24 16:02:24 2022] [ 518] 0 518 8738 361 21 70 0 cron[月 12日 24 16:02:24 2022] [ 519] 0 519 4756 314 13 45 0 atd[月 12日 24 16:02:24 2022] [ 520] 0 520 13795 412 31 143 -1000 sshd[月 12日 24 16:02:24 2022] [ 525] 0 525 4964 161 14 65 0 systemd-logind[月 12日 24 16:02:24 2022] [ 536] 105 536 10531 172 26 98 -900 dbus-daemon[月 12日 24 16:02:24 2022] [ 580] 0 580 1064 362 8 34 0 acpid[月 12日 24 16:02:24 2022] [ 602] 0 602 4926 373 13 37 0 agetty[月 12日 24 16:02:24 2022] [ 605] 0 605 4881 373 14 37 0 agetty[月 12日 24 16:02:24 2022] [ 643] 108 643 8346 283 22 134 0 ntpd[月 12日 24 16:02:24 2022] [ 889] 104 889 12794 369 26 158 0 exim4[月 12日 24 16:02:24 2022] [11640] 0 11640 4188 1118 15 0 0 atop[月 12日 24 16:02:24 2022] [29370] 0 29370 14434 420 30 177 0 sshd[月 12日 24 16:02:24 2022] [29372] 3010 29372 14434 189 29 147 0 sshd[月 12日 24 16:02:24 2022] [29373] 3010 29373 7813 491 20 587 0 bash[月 12日 24 16:02:24 2022] [30731] 0 30731 14434 429 30 177 0 sshd[月 12日 24 16:02:24 2022] [30733] 3010 30733 14434 328 29 154 0 sshd[月 12日 24 16:02:24 2022] [30734] 3010 30734 7810 432 19 606 0 bash[月 12日 24 16:02:24 2022] [30746] 3010 30746 13967 408 30 102 0 su[月 12日 24 16:02:24 2022] [30747] 0 30747 7389 422 19 194 0 bash[月 12日 24 16:02:24 2022] [31688] 0 31688 13967 408 31 101 0 su[月 12日 24 16:02:24 2022] [31689] 3010 31689 7808 482 19 566 0 bash[月 12日 24 16:02:24 2022] [32128] 3010 32128 7761 445 19 32 0 top[月 12日 24 16:02:24 2022] [32132] 3010 32132 2357921 1868878 4581 467803 0 python[月 12日 24 16:02:24 2022] [32133] 3010 32133 1255 152 7 57 0 strace[月 12日 24 16:02:24 2022] Out of memory: Kill process 32132 (python) score 957 or sacrifice child[月 12日 24 16:02:24 2022] Killed process 32132 (python) total-vm:9431684kB, anon-rss:7473936kB, file-rss:1576kB</code></pre><p>结果很明显OOM了。简单粗暴：直接加内存即可；但后续需找出好内存的代码段，进行优化。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存淘汰算法：LRU、TTL</title>
      <link href="/2022/07/14/chang-yong-huan-cun-tao-tai-suan-fa/"/>
      <url>/2022/07/14/chang-yong-huan-cun-tao-tai-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h3><p>LRU(Least recently used, 最近最少使用)，其核心思想是：如果一个数据最近一段时间被访问过，那么以后被访问的几率越高，如果一个数据最近一段时间没有被访问过，那么将来被访问的几率越小；当内存超过限制时，应当把最久没有访问的数据淘汰。</p><blockquote><p>实现LRU</p></blockquote><ol><li><p>用一个先进先出的队列来记录缓存的key，每当某个key被访问，就将该key入队；如果该key在这个队列里面，则将该key移至队尾；若队列已满，则淘汰队首的key。</p></li><li><p>利用dict来存储key对应的数据项；当有新key入队，则该dict需要插入新数据项；若队列已满，同时要将队首的key所存储的数据项淘汰</p></li></ol><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> max_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        self<span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>max_size <span class="token operator">=</span> max_size    <span class="token keyword">def</span> <span class="token function">visit_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">full</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        key <span class="token operator">=</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>keys <span class="token operator">=</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        value <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>visit_key<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> value    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>keys<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>max_size<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>visit_key<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TTL-Cache"><a href="#TTL-Cache" class="headerlink" title="TTL Cache"></a>TTL Cache</h3><p>TTL 简单来讲就是对数据缓存一定的时间<br>上代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ttl_cache</span><span class="token punctuation">(</span>ttl<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            target <span class="token operator">=</span> object<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> kwargs<span class="token punctuation">:</span>                key <span class="token operator">=</span> args <span class="token operator">+</span> <span class="token punctuation">(</span>repr<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>kwargs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                key <span class="token operator">=</span> args            result <span class="token operator">=</span> cache<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span> target<span class="token punctuation">)</span>            <span class="token keyword">if</span> result <span class="token keyword">is</span> <span class="token operator">not</span> target<span class="token punctuation">:</span>                exp<span class="token punctuation">,</span> value <span class="token operator">=</span> result                <span class="token keyword">if</span> exp <span class="token operator">></span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hit cache: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>exp<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> value            value <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"miss cache"</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ttl<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            <span class="token keyword">return</span> value        <span class="token keyword">return</span> inner    <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastApi学习总结</title>
      <link href="/2021/11/26/fastapi-xue-xi-zong-jie/"/>
      <url>/2021/11/26/fastapi-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p> <code>官网学习教程：</code><a href="https://fastapi.tiangolo.com/zh/" target="_blank" rel="noopener"><code>https://fastapi.tiangolo.com/zh/</code></a></p><h2 id="一、为什么要使用-FastAPI-FastAPI有哪些特点"><a href="#一、为什么要使用-FastAPI-FastAPI有哪些特点" class="headerlink" title="一、为什么要使用 FastAPI; FastAPI有哪些特点?"></a>一、为什么要使用 FastAPI; FastAPI有哪些特点?</h2><h3 id="1-快速："><a href="#1-快速：" class="headerlink" title="1.快速："></a>1.快速：</h3><p>拥有非常高的性能，归功于 Starlette 和 Pydantic；Starlette 用于路由匹配，Pydantic 用于数据验证</p><p> Starlette</p><pre><code>       1.官网使用介绍: https://www.starlette.io/       2.什么是 Starlette?        Starlette 是一种轻量级的 ASGI 框架/工具包，是构建高性能 asyncio 服务的理想选择。       3.为什么使用 Starlette?        Starlette 是目前测试最快的 Python 框架。只有 Uvicorn 超越了它，Uvicorn 不是框架，而是服务器。       4.其他        Starlette 提供了所有基本的 Web 微框架功能。但是它不提供自动数据验证，序列化或API 文档。        自动数据验证由 Pydantic负责, API文档则是 OpenAPI          FastAPI 使用它来处理所有核心 Web 部件, 类 FastAPI 本身直接继承Starlette。</code></pre><p>因此，使用 Starlette 可以执行的任何操作，都可以直接使用 FastAPI 进行。</p><pre><code>        即路由匹配规则之内的 具体实现都要看 Starlette源码</code></pre><p>  Pydantic</p><pre><code>       1.官网使用介绍:</code></pre><p><a href="https://pydantic-docs.helpmanual.io/" target="_blank" rel="noopener">https://pydantic-docs.helpmanual.io/</a></p><pre><code>       2.什么是Pydantic?            Pydantic 是一个库，基于Python类型提示来定义数据验证，序列化和文档（使用JSON模式）。       3.为什么使用 Pydantic?            FastAPI使用它来处理所有数据验证, 除了pydantic库之外，像是valideer库、marshmallow库、trafaret库以及cerberus库等都可以完成相似的功能，但是相较之下，pydantic库的执行效率会更加优秀一些。</code></pre><p>Uvicorn</p><p>   1.官网使用介绍</p><pre><code>    [https://www.uvicorn.org/](https://www.uvicorn.org/)</code></pre><p>   2.什么是 Uvicorn？</p><pre><code>Uvicorn 是基于 uvloop 和 httptools 构建的如闪电般快速的 ASGI 服务器。它不是Web框架，而是服务器</code></pre><h3 id="2-开发效率："><a href="#2-开发效率：" class="headerlink" title="2.开发效率："></a>2.开发效率：</h3><p>功能开发效率提升 200% 到 300%</p><pre><code>  2.1 路径参数/查询参数/Body参数 的提取与校验都被最大程度的支持  2.2 依赖注入能较大程度的复用公共逻辑</code></pre><h3 id="3-减少-bug："><a href="#3-减少-bug：" class="headerlink" title="3.减少 bug："></a>3.减少 bug：</h3><p>减少 40% 的因为开发者粗心导致的错误</p><p>  Pydantic提供的 数据验证功能与 类型注释的结合能有效的减少BUG</p><h3 id="4-智能："><a href="#4-智能：" class="headerlink" title="4.智能："></a>4.智能：</h3><p>内部的类型注解非常完善，编辑器可处处自动补全</p><p>  支持Pydantic的IDE(编辑器)都能很好的支持补全等操作</p><h3 id="5-简单："><a href="#5-简单：" class="headerlink" title="5.简单："></a>5.简单：</h3><p>框架易于使用，文档易于阅读</p><h3 id="6-简短："><a href="#6-简短：" class="headerlink" title="6.简短："></a>6.简短：</h3><p>使代码重复最小化，通过不同的参数声明实现丰富的功能</p><pre><code>  依赖注入</code></pre><h3 id="7-健壮："><a href="#7-健壮：" class="headerlink" title="7.健壮："></a>7.健壮：</h3><p>可以编写出线上使用的代码，并且会自动生成交互式文档</p><h3 id="8-标准化："><a href="#8-标准化：" class="headerlink" title="8.标准化："></a>8.标准化：</h3><p>兼容 API 相关开放标准</p><h2 id="二、FastAPI开发的相关依赖"><a href="#二、FastAPI开发的相关依赖" class="headerlink" title="二、FastAPI开发的相关依赖"></a>二、FastAPI开发的相关依赖</h2><h3 id="1-Python"><a href="#1-Python" class="headerlink" title="1. Python"></a>1. Python</h3><p>  Python的版本要大于等于 3.6</p><h3 id="2-其他模块依赖"><a href="#2-其他模块依赖" class="headerlink" title="2. 其他模块依赖"></a>2. 其他模块依赖</h3><p>  pip install fastapi; 该操作会自动安装 Starlette 和 Pydantic</p><p>  pip install uvicorn;  uvicorn 是运行相关应用程序的服务器</p><p>  pip install fastapi[all]; 一步到位, 所有依赖全部安装</p><h2 id="三、交互式文档"><a href="#三、交互式文档" class="headerlink" title="三、交互式文档"></a>三、交互式文档</h2><p> FastAPI 会自动提供一个类似于 Swagger 的交互式文档，我们输入 “localhost:port/docs” 即可进入。</p><p> 交互式文档会显示 接口API的相关内容, 并且可以自定义接口信息, 具体如何操作, 后续再更新</p><h2 id="四、路由相关"><a href="#四、路由相关" class="headerlink" title="四、路由相关"></a>四、路由相关</h2><h3 id="1-路由匹配规则"><a href="#1-路由匹配规则" class="headerlink" title="1.路由匹配规则"></a>1.路由匹配规则</h3><p>1.1 普通路由匹配</p><p>  在一个 路由定义模块中, 若一个URL可以匹配上多个 自定义路由的情况下</p><p>  会优先匹配到 先定义的那一个。</p><p>举个例子:</p><pre><code># coding: utf-8from fastapi import FastAPIimport uvicornapp = FastAPI()@app.get(&quot;/users/me&quot;)async def read_user_me():    return {&quot;user_id&quot;: &quot;the current user&quot;}@app.get(&quot;/users/{user_id}&quot;)async def read_user(user_id: int):    return {&quot;user_id&quot;: user_id}if __name__ == &quot;__main__&quot;:    uvicorn.run(&quot;main:app&quot;, host=&quot;0.0.0.0&quot;, port=8080)</code></pre><p><strong>因为路径操作是按照顺序进行的，所以这里要保证</strong> <code>/users/me</code> <strong>在</strong> <code>/users/{user\_id}</code> <strong>的前面，否则的话只会匹配到</strong> <code>/users/{user\_id}</code><strong>，此时如果访问</strong> <code>/users/me</code><strong>，那么会返回一个解析错误，因为字符串 “me” 无法解析成整型。</strong></p><h3 id="2-APIRouter路由组"><a href="#2-APIRouter路由组" class="headerlink" title="2.APIRouter路由组"></a>2.APIRouter路由组</h3><p>APIRouter主要是给路由加前缀, 方便于在项目中 对于不同模块或者不同类别的接口 加一个统一的前缀进行绑定, 有点类似分组/文件夹的意思</p><p>APIRouter: 有点类似于GO中gin框架中的路由组的概念, 所以这里写的是路由组</p><p>使用方式如下:</p><p>1.在app具体的模块中</p><pre><code># app/user/user_login.pyfrom fastapi import APIRouteruser_router = APIRouter(prefix=&quot;/v1/users&quot;)# 以后访问的时候要通过 /v1/users/login     来访问@router.get(&quot;/login&quot;)async def v1():    return {&quot;message&quot;: &quot;hello world&quot;}</code></pre><p>2.在项目启动加载的 main.py中:</p><pre><code># main.pyfrom fastapi import FastAPIfrom app.user.user_login import user_routerimport uvicornapp = FastAPI()# 将 user_router 注册到 app 中，相当于 Flask 中的 register_blueprintapp.include_router(router)if __name__ == &quot;__main__&quot;:    uvicorn.run(&quot;main:app&quot;, host=&quot;0.0.0.0&quot;, port=8080)</code></pre><h3 id="3-禁用一个路由"><a href="#3-禁用一个路由" class="headerlink" title="3.禁用一个路由:"></a>3.禁用一个路由:</h3><p>参数 include_in_schema 设置为 False</p><p> @app.get(“/items/“, include_in_schema=False)</p><p>但是这个 禁用路由仅仅只是在 docs页面隐藏该 接口 不显示, 实际上并不影响其调用和真正使用。只是接口文档处对外界不可知~</p><h2 id="五、请求参数获取"><a href="#五、请求参数获取" class="headerlink" title="五、请求参数获取"></a>五、请求参数获取</h2><p>PS： 这里只介绍参数获取, 对于参数校验的写法， 详见第六章</p><h3 id="5-1-获取路径参数"><a href="#5-1-获取路径参数" class="headerlink" title="5.1 获取路径参数"></a>5.1 获取路径参数</h3><p>路径参数的声明:</p><p>路径参数声明在url中, 并且用一对花括号<code>{user\_id}</code>包裹； eg. <code>@app.get(&quot;/user/{user\_id}&quot;)</code></p><p>对于多个 路径参数来说, 用多个 <code>{}</code> 包裹即可；eg. <code>@app.get(&quot;/user/{part\_id}/{user\_name}&quot;)</code></p><p>路径参数的获取:</p><pre><code>@app.get(&quot;/user/{part_id}/{user_name}&quot;)async def get_user(part_id: str, user_name: str):    &quot;&quot;&quot;在路由函数中定义的两个路径参数 part_id/user_name        只要路由函数中的 参数名能与之对应(一模一样),         那么在这里路由函数获取的 part_id/user_name就是路径参数上对应的 part_id/user_name       在路由函数中 这两个参数的顺序没有要求    &quot;&quot;&quot;    return {&quot;part_id&quot;: part_id, &quot;user_name&quot;: user_name}</code></pre><p>对于特殊路径参数的获取, 详见 5.4 获取path类型参数</p><h3 id="5-2-获取params参数"><a href="#5-2-获取params参数" class="headerlink" title="5.2 获取params参数"></a>5.2 获取params参数</h3><p>查询参数不需要声明, 如果函数中定义了不属于路径参数的参数时，那么它们将会被自动解释会查询参数。</p><p><strong>方式一: 默认方式</strong></p><pre><code>@app.get(&quot;/user/{user_id}&quot;)async def get_user(user_id: str, name: str, age: int):    &quot;&quot;&quot;我们在函数中参数定义了 user_id、name、age 三个参数       显然 user_id 和 路径参数中的 user_id 对应，然后 name 和 age 会被解释成查询参数       这三个参数的顺序没有要求，但是一般都是路径参数在前，查询参数在后       PS: 这里做了 类型注释, 因此传进来的 参数会经过 是否必要性检测即参数类型检测               这里的声明表示, params参数 name/age 是必填参数, 没有传会抛错            虽然params参数的数据框架在接收的时候, value都是 str类型的, 但是这里声明 age: int时,             age: &#39;10&#39; 会被强转为 age: 10; 但是对于 age: &#39;test&#39; 这类的参数 则会报类型错误~    &quot;&quot;&quot;    return {&quot;user_id&quot;: user_id, &quot;name&quot;: name, &quot;age&quot;: age}</code></pre><p>方式二: 使用Query 类型注释</p><pre><code>@app.get(&quot;/user/{user_id}&quot;)async def get_user(user_id: str, name: str=Query(...), age: int=Query(...)):    return {&quot;user_id&quot;: user_id, &quot;name&quot;: name, &quot;age&quot;: age}</code></pre><h3 id="5-3-获取body参数"><a href="#5-3-获取body参数" class="headerlink" title="5.3 获取body参数"></a>5.3 获取body参数</h3><h4 id="5-3-1-获取json类型-body参数-单个请求体"><a href="#5-3-1-获取json类型-body参数-单个请求体" class="headerlink" title="5.3.1 获取json类型 body参数(单个请求体)"></a>5.3.1 获取json类型 body参数(单个请求体)</h4><p><strong>方式一: 使用Body类型</strong></p><pre><code>from datetime import datetime, time, timedeltafrom typing import Optionalfrom uuid import UUIDfrom fastapi import Body, FastAPIapp = FastAPI()</code></pre><p>​<br>    @app.put(“/items/{item_id}”)<br>    async def read_items(<br>        item_id: UUID,<br>        start_datetime: Optional[datetime] = Body(None),        # 这里的 Body类型注释 表明了获取的是一个 body参数<br>        end_datetime: Optional[datetime] = Body(None),<br>        repeat_at: Optional[time] = Body(None),<br>        process_after: Optional[timedelta] = Body(None),<br>    ):<br>        start_process = start_datetime + process_after<br>        duration = end_datetime - start_process<br>        return {<br>            “item_id”: item_id,<br>            “start_datetime”: start_datetime,<br>            “end_datetime”: end_datetime,<br>            “repeat_at”: repeat_at,<br>            “process_after”: process_after,<br>            “start_process”: start_process,<br>            “duration”: duration,<br>        }</p><p><strong>方式二: 继承BaseModel （Pydantic提供）</strong></p><p>如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。</p><pre><code>from typing import Optional, Listfrom fastapi import FastAPI, Request, Responsefrom pydantic import BaseModelimport uvicornapp = FastAPI()</code></pre><p>​<br>    class Girl(BaseModel):<br>        “””数据验证是通过 pydantic 实现的，我们需要从中导入 BaseModel，然后继承它”””<br>        name: str<br>        age: Optional[str] = None<br>        length: float<br>        hobby: List[str]  # 对于 Model 中的 List[str] 我们不需要指定 Query（准确的说是 Field）</p><p>​<br>    @app.post(“/girl”)<br>    async def read_girl(girl: Girl):<br>        # girl 就是我们接收的请求体，它需要通过 json 来传递，并且这个 json 要有上面的四个字段（age 可以没有）<br>        # 通过 girl.xxx 的方式我们可以获取和修改内部的所有属性<br>        return dict(girl)  # 直接返回 Model 对象也是可以的</p><h4 id="5-3-2-获取json类型-body参数-多个请求体"><a href="#5-3-2-获取json类型-body参数-多个请求体" class="headerlink" title="5.3.2 获取json类型 body参数(多个请求体)"></a>5.3.2 获取json类型 body参数(多个请求体)</h4><p>上面只是接收一个请求体的情况, 如果是接收两个请求体呢？</p><pre><code>class Girl(BaseModel):    name: str    age: Optional[str] = Noneclass Boy(BaseModel):    name: str    age: int@app.post(&quot;/boy_and_girl&quot;)async def read_boy_and_girl(girl: Girl,                            boy: Boy):    return {&quot;girl&quot;: dict(girl), &quot;boy&quot;: dict(boy)}</code></pre><p>对于上述这种写法, 在传入body数据时, 在json串中 应该有两个子json串，且其key分别为 girl/boy</p><p>如何理解?</p><p>实际上对于 继承了 BaseModel或者 路由函数中 直接使用 Body类型进行声明的 参数, 框架都会接收为 body参数, 这些body参数可以看做是关键字参数, 但是当 只有一个 BaseModel类型时, 就可以不使用关键字进行识别</p><p>上述案例的请求体示例如下:</p><pre><code>{    &quot;girl&quot;: {&quot;name&quot;: &quot;新垣结衣&quot;, &quot;age&quot;: 18},    &quot;boy&quot;: {&quot;name&quot;: &quot;星野源&quot;, &quot;age&quot;: 18}}</code></pre><p>PS: 其实上述写法, 也可以只是用一个 请求体来表示( 即这种 BaseModel的写法是可以多层嵌套的~)</p><pre><code>class Girl(BaseModel):    name: str    age: Optional[str] = Noneclass Boy(BaseModel):    name: str    age: intclass BoyGirl(BaseModel):    girl: Girl    boy: Boy@app.post(&quot;/boy_and_girl&quot;)async def read_boy_and_girl(boy_girl: BoyGirl):    return dict(boy_girl)</code></pre><h4 id="5-3-3-获取from表单数据"><a href="#5-3-3-获取from表单数据" class="headerlink" title="5.3.3 获取from表单数据"></a>5.3.3 获取from表单数据</h4><p><strong>方式一: 使用 Form 类型</strong></p><pre><code>from fastapi import FastAPI, Formapp = FastAPI()@app.post(&quot;/login&quot;)async def user_login(username: str = Form(...),        # 这里的Form类型 表明接收的是 form表单的数据                   password: str = Form(...)):    return {&quot;username&quot;: username, &quot;password&quot;: password}</code></pre><p><strong>方式二：使用request</strong></p><pre><code>from fastapi import FastAPI, Requestapp = FastAPI()@app.post(&quot;/girl&quot;)async def girl(request: Request):    # 此时 await request.json() 报错，因为是通过 data 参数传递的，相当于 form 表单提交    # 如果是通过 json 参数传递，那么 await request.form() 会得到一个空表单    form = await request.form()    return [form.get(&quot;name&quot;), form.getlist(&quot;age&quot;)]</code></pre><p>PS: python如何发送 form表单数据（使用 data参数）</p><pre><code>requests.post(url, data={&quot;name&quot;: &quot;test1&quot;, &quot;password&quot;: &quot;test2&quot;})</code></pre><h4 id="5-3-4-获取文件上传数据"><a href="#5-3-4-获取文件上传数据" class="headerlink" title="5.3.4 获取文件上传数据"></a>5.3.4 获取文件上传数据</h4><p><strong>1.获取单个文件(使用 File类型)</strong></p><pre><code>from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(&quot;/file1&quot;)async def file1(file: bytes = File(...)):        # 这里使用的是 File类型 接收的是一个 bytes 字节流    return f&quot;文件长度: {len(file)}&quot;@app.post(&quot;/file2&quot;)async def file1(file: UploadFile = File(...)):        # 这里接收的是 一个文件句柄对象, 这两种方式都可以获取到上传的文件    return f&quot;文件名: {file.filename}, 文件大小: {len(await file.read())}&quot;</code></pre><p><strong>2.获取多个文件</strong></p><pre><code>@app.post(&quot;/file&quot;)async def file(files: List[UploadFile] = File(...)):    &quot;&quot;&quot;指定类型为列表即可&quot;&quot;&quot;    for idx, f in enumerate(files):        files[idx] = f&quot;文件名: {f.filename}, 文件大小: {len(await f.read())}&quot;    return f</code></pre><p>PS： Python如何上传文件?</p><p>首先如果想使用文件上传功能，那么你必须要安装一个包 python-multipart，直接 pip install python-multipart 即可。</p><pre><code># 上传单个文件requests.post(url, files={&quot;file&quot;: open(r&quot;/file_path/file_name&quot;, &quot;rb&quot;)})# 上传多个文件requests.post(url, files={&quot;file&quot;: [            (&quot;files&quot;, open(r&quot;/file_path1/file_name1&quot;),               (&quot;files&quot;, open(r&quot;/file_path2/file_name2&quot;),            (&quot;files&quot;, open(r&quot;/file_path3/file_name3&quot;)]})</code></pre><h3 id="5-4-获取path类型参数"><a href="#5-4-获取path类型参数" class="headerlink" title="5.4 获取path类型参数"></a>5.4 获取path类型参数</h3><p>假设我们有这样一个路由：<code>/files/{file\_path}</code>，而用户传递的 file_path 中显然是可以带 / 的，假设 file_path 是 <code>/root/test.py</code>，那么路由就变成了 <code>/files//root/test.py</code>，显然这样子进行路由匹配就会出问题。</p><p>这是我们需要声明 file_path 的类型为 path, eg. @app.get(“/files/{file_path:path}”)</p><p><strong>方式一: 声明path类型</strong></p><pre><code>from fastapi import FastAPIapp = FastAPI()</code></pre><p>​<br>    # 声明 file_path 的类型为 path，这样它会被当成一个整体<br>    @app.get(“/files/{file_path:path}”)<br>    async def get_file(file_path: str):<br>        return {“file_path”: file_path}</p><p><strong>方式二: 使用Path 类型注释</strong></p><pre><code>from fastapi import FastAPI, Path@app.get(&quot;/items/{item-id}&quot;)# 这里用 Path类型来接收, 也会将后面的整体作为一个path.# 这里的 alias表示 重命名, 也就是将 路由函数中的 变量 item_id 与 路由中的 item-id 对应上.async def read_items(item_id: int = Path(..., alias=&quot;item-id&quot;)):    return {&quot;item_id&quot;: item_id}</code></pre><p>PS: 也就是说, 当路径参数中 声明了 一个参数为 Path类型, 那么这个参数后面不能在接其他的路径参数。即 <code>@app.get(&quot;/files/{file\_path:path}/{user\_id}&quot;)</code> 这样的写法， user_id就获取不到~</p><h3 id="5-5-多种请求参数混合获取"><a href="#5-5-多种请求参数混合获取" class="headerlink" title="5.5 多种请求参数混合获取"></a>5.5 多种请求参数混合获取</h3><h4 id="5-5-1-路由函数中使用类型区别"><a href="#5-5-1-路由函数中使用类型区别" class="headerlink" title="5.5.1 路由函数中使用类型区别"></a>5.5.1 路由函数中使用类型区别</h4><p><strong>方式一: 直接使用内置方式获取</strong></p><p>1.如果在路径中也声明了该参数，它将被用作路径参数</p><p>2.如果参数属于单一类型（比如 int、float、str、bool 等）它将被解释为查询参数。</p><p>   3.如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。</p><pre><code>from fastapi import FastAPIfrom pydantic.main import BaseModelapp = FastAPI()class Girl(BaseModel):    name: str    age: int@app.get(&quot;/user/{user_id}&quot;)async def get_user(user_id: str, name: str, age: int, girl: Girl):    # user_id 为路径参数    # name/age 为params参数    # girl 为body参数    return {&quot;user_id&quot;: user_id, &quot;name&quot;: name, &quot;age&quot;: age, &quot;girl&quot;: girl.dict()}</code></pre><p><strong>方式二: 使用 类型注释来获取</strong></p><p>Path(路径参数)/Query(params参数)/Body(json请求体)/Form(form表单请求体)/File(文件)</p><p>Cookie(cookie参数)/Header(请求头)</p><p>关于 Path(路径参数)/Query(params参数)/Body(json请求体)/Form(form表单请求体)/File(文件)的使用方式, 上面已经有过展示， 这里不再赘述</p><p>Cookie:</p><p>1.声明：ads_id: Optional[str] = Cookie(None)</p><p>Header：</p><p>1.声明： user_agent: Optional[str] = Header(None)</p><p>2.默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers.</p><p>3.设置Header的参数 convert_underscores 为 False, 可以取消上述的 下划线到连字符的自动转换</p><p>4.headers 是大小写不敏感的</p><p>5.声明多个header: x_token: Optional[List[str]] = Header(None) –&gt; 例: 使用header传输 cookie的情况</p><p>PS：</p><p>Cookie 、Header、Path 、Query是兄弟类，它们都继承自公共的 Param 类 –&gt; 很明显Body/File/Form不是</p><h4 id="5-5-2-使用request对象获取"><a href="#5-5-2-使用request对象获取" class="headerlink" title="5.5.2 使用request对象获取"></a>5.5.2 使用request对象获取</h4><p>任何一个请求都对应一个 Request 对象，请求的所有信息都在这个 Request 对象中</p><p>获取参数方式如下：</p><pre><code>@app.get(&quot;/girl/{user_id}&quot;)async def read_girl(user_id: str,                    request: Request):    &quot;&quot;&quot;路径参数是必须要体现在参数中，但是查询参数可以不写了       因为我们定义了 request: Request，那么请求相关的所有信息都会进入到这个 Request 对象中&quot;&quot;&quot;    header = request.headers  # 请求头    method = request.method  # 请求方法    cookies = request.cookies  # cookies    query_params = request.query_params  # 查询参数    body_data = await request.json()  # 获取json请求体, 该函数本质上步骤为: body = await self.body() + self._json = json.loads(body)    return {&quot;name&quot;: query_params.get(&quot;name&quot;), &quot;age&quot;: query_params.get(&quot;age&quot;), &quot;hobby&quot;: query_params.getlist(&quot;hobby&quot;)}</code></pre><h4 id="5-5-3-参数顺序"><a href="#5-5-3-参数顺序" class="headerlink" title="5.5.3 参数顺序"></a>5.5.3 参数顺序</h4><p>路径参数应该在查询参数的前面，尽管 FastAPI 没有这个要求，但是这样写明显更舒服一些。但是问题来了，如果路径参数需要指定别名，但是某一个查询参数不需要，这个时候就会出现问题</p><pre><code>@app.get(&quot;/items/{item-id}&quot;)async def read_items(q: str,                     item_id: int = Path(..., alias=&quot;item-id&quot;)):    return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}</code></pre><p>显然此时 Python 的语法就决定了 item_id 就必须放在 q 的后面，当然这么做是完全没有问题的，FastAPI 对参数的先后顺序没有任何要求，因为它是通过参数的名称、类型和默认值声明来检测参数，而不在乎参数的顺序。但此时我们就要让 item_id 在 q 的前面要怎么做呢？</p><pre><code>@app.get(&quot;/items/{item-id}&quot;)async def read_items(*, item_id: int = Path(..., alias=&quot;item-id&quot;),                     q: str):    return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}</code></pre><p>通过将第一个参数设置为 *，使得 item_id 和 q 都必须通过关键字传递，所以此时默认参数在非默认参数之前也是允许的。当然我们也不需要担心 FastAPI 传参的问题，你可以认为它所有的参数都是通过关键字参数的方式传递的。</p><h2 id="六、数据校验"><a href="#六、数据校验" class="headerlink" title="六、数据校验"></a>六、数据校验</h2><h3 id="6-1-类型注释的数据校验方式"><a href="#6-1-类型注释的数据校验方式" class="headerlink" title="6.1 类型注释的数据校验方式"></a>6.1 类型注释的数据校验方式</h3><p>Path(路径参数)/Query(params参数)/Body(json请求体)/Form(form表单请求体)/File(文件)/Cookie(cookie参数)/Header(请求头)</p><p>上述这些 类在用于 类型注释时, 使用方式基本都差不多, 只是在某些方面有一些细微的差别</p><p>6.1.1 公共校验部分</p><p>这里以Query为例</p><pre><code>Query(            None,            alias=&quot;item-query&quot;,            title=&quot;Query string&quot;,            description=&quot;Query string for the items to search in the database that have a good match&quot;,            min_length=3,            max_length=50,            regex=&quot;^fixedquery$&quot;,            deprecated=True,        )        1.修改额外的原数据:            alias - 起别名            title/description - 文档描述            deprecated - 参数弃用标识        2.用于校验的参数：                min_length/max_length    长度匹配            regex        正则匹配        3.数值校验:            gt/ge/lt/le： 大于/大于等于/小于/小于等于 定义为float类型        4.设置必填/非必填/默认值        Query(...)    - 设置为必填         Query(None) - 设置为非必填      Query(&quot;test&quot;) - 设置默认值 test     5.接收列表         q: Optional[List[str]] = Query(None) 定义 query参数为必填的list, 即能匹配 xxx_url?q=foo&amp;q=bar ---&gt; q=[&#39;foo&#39;, &#39;bar&#39;]     6.指定数据接收类型         q:  Optional[str] = Query(...)      q: str          这里支持的数据类型:      int/float/str/bool/list/dict/set      UUID/datetime.datetime(2008-09-15T15:53:00+05:00)/datetime.date(2008-09-15)      datetime.time(14:23:55.003)/datetime.timedelta(时间戳秒数)/bytes/Decimal(框架内可当做float使用)         支持指定多种数据类型：          user_id: Union[int, str]</code></pre><p>举个例子:</p><pre><code>@app.get(&quot;/user&quot;)async def check_length(        password: str = Query(&quot;satori&quot;, min_length=6, max_length=15, regex=r&quot;^satori&quot;)):    &quot;&quot;&quot;此时的 password 默认值为 &#39;satori&#39;，并且传递的时候必须要以 &#39;satori&#39; 开头       但是值得注意的是 password 后面的是 str，不再是 Optional[str]，因为默认值不是 None 了       当然这里即使写成 Optional[str] 也是没有什么影响的    &quot;&quot;&quot;    return {&quot;password&quot;: password}</code></pre><p>​<br>    @app.get(“/items”)<br>    async def read_items(<br>            a1: str = Query(…),    # … 设置为必填参数<br>            a2: List[str] = Query(…), # 查询参数变成一个列表; 对应于 url后 a=1&amp;a=2的情况<br>            b: List[str] = Query(…)<br>    ):<br>        return {“a1”: a1, “a2”: a2, “b”: b}</p><pre><code>@app.get(&quot;/items&quot;)async def read_items(        # item1 必须大于 5        item1: int = Query(..., gt=5),        # 数值检测        # item2 必须小于等于 7        item2: int = Query(..., le=7),        # item3 必须必须等于 10        item3: int = Query(..., ge=10, le=10)):    return {&quot;item1&quot;: item1, &quot;item2&quot;: item2, &quot;item3&quot;: item3}</code></pre><h4 id="6-1-2-各类型特殊部分"><a href="#6-1-2-各类型特殊部分" class="headerlink" title="6.1.2 各类型特殊部分"></a>6.1.2 各类型特殊部分</h4><p><strong>Path:</strong></p><p>1.路径参数总是必须的, 所以应表示为Path(…), 即使写为了 Path(None), 也还是一个必选参数</p><p><strong>Header：</strong></p><p>1.默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers.</p><p>2.设置Header的参数 convert_underscores 为 False, 可以取消上述的 下划线到连字符的自动转换</p><p>3.headers 是大小写不敏感的</p><h4 id="6-1-3-特殊检验类型-Filed"><a href="#6-1-3-特殊检验类型-Filed" class="headerlink" title="6.1.3 特殊检验类型 Filed"></a>6.1.3 特殊检验类型 Filed</h4><p>Filed与BaseModel一样, 由pydantic模块提供</p><p>Filed类型的用法与 Query一致, 唯一的区别就是Filed可以对所有类型的 参数进行参数校验，而不像Query/Body这类参数, 在校验时, 只能获取对应的参数。</p><p>如果有个 username参数即在 params参数中会出现， 在body参数中也会出现, 甚至于在 response 中也可能会出现， 此时使用 Filed进行参数验证就比较合适</p><p>Filed的使用 示例见 6.3</p><h3 id="6-2-变量类型声明的特殊情况"><a href="#6-2-变量类型声明的特殊情况" class="headerlink" title="6.2 变量类型声明的特殊情况"></a>6.2 变量类型声明的特殊情况</h3><h4 id="6-2-1-默认值与声明值可不同"><a href="#6-2-1-默认值与声明值可不同" class="headerlink" title="6.2.1 默认值与声明值可不同"></a>6.2.1 默认值与声明值可不同</h4><pre><code>@app.get(&quot;/user/{user_id}&quot;)async def get_user(user_id: str, name: str = &quot;UNKNOWN&quot;, age: int = &quot;哈哈哈&quot;):    # 这里的 age 需要接收一个整型，但是默认值却是一个字符串    return {&quot;user_id&quot;: user_id, &quot;name&quot;: name, &quot;age&quot;: age}</code></pre><p>这种情况下传递的 age 依旧需要整型，只不过在不传的时候会使用字符串类型的默认值，所以类型和默认值类型不同的时候也是可以的</p><h4 id="6-2-2-同一个变量指定多个类型"><a href="#6-2-2-同一个变量指定多个类型" class="headerlink" title="6.2.2 同一个变量指定多个类型"></a>6.2.2 同一个变量指定多个类型</h4><pre><code>from typing import Union, Optional@app.get(&quot;/user/{user_id}&quot;)async def get_user(user_id: Union[int, str], name: Optional[str] = None):    &quot;&quot;&quot;通过 Union 来声明一个混合类型，int 在前、str 在后。会先按照 int 解析，解析失败再变成 str       然后是 name，它表示字符串类型、但默认值为 None（不是字符串），那么应该声明为 Optional[str]&quot;&quot;&quot;    return {&quot;user_id&quot;: user_id, &quot;name&quot;: name}</code></pre><h4 id="6-2-3指定数据接收类型"><a href="#6-2-3指定数据接收类型" class="headerlink" title="6.2.3指定数据接收类型"></a>6.2.3指定数据接收类型</h4><p>q: Optional[str] = Query(…)</p><p>q: str</p><p>这里支持的数据类型:</p><p><code>int/float/str/bool/list/dict/set</code></p><p><code>UUID/datetime.datetime(2008-09-15T15:53:00+05:00)/datetime.date(2008-09-15)</code></p><p><code>datetime.time(14:23:55.003)/datetime.timedelta(时间戳秒数)/bytes/Decimal(框架内可当做float使用)</code></p><p>支持指定多种数据类型：</p><p>user_id: Union[int, str]</p><h3 id="6-3-BaseModel校验方式"><a href="#6-3-BaseModel校验方式" class="headerlink" title="6.3 BaseModel校验方式"></a>6.3 BaseModel校验方式</h3><p>这里是用了 Filed做示例, 如果是 Body参数, 使用Body也可，其他的类推~</p><p>示例如下:</p><pre><code>class UserIn(BaseModel):    &quot;&quot;&quot;用户信息 请求格式&quot;&quot;&quot;    name: str = Field(..., min_length=1, max_length=64)    password: str = Field(..., min_length=1, max_length=32)    nickname: str = Field(None, max_length=64)    phone: str = Field(None, max_length=16, regex=r&#39;^1(3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[0-35-9])\d{8}$&#39;)    # 正则匹配    email: str = Field(None, max_length=32, regex=r&#39;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$&#39;)class UserOut(BaseModel):    &quot;&quot;&quot;用户信息响应格式&quot;&quot;&quot;    id: str = Field(..., max_length=32)    name: str = Field(..., min_length=1, max_length=64)    nickname: str = Field(None, max_length=64)    last_login_address: str = Field(None, max_length=32)    last_login_time: datetime.datetime = Field(None)    # 指定datetime类型    login_counts: int = Field(0)        # 设置默认值 0    phone: str = Field(None, max_length=16)        # 设置为非必须字段    email: str = Field(None, max_length=32)    enabled: int = Field(1)    is_deleted: int = Field(0)</code></pre><h3 id="6-4-HTTP验证-security"><a href="#6-4-HTTP验证-security" class="headerlink" title="6.4 HTTP验证 security"></a>6.4 HTTP验证 security</h3><p>通过输入用户名和密码来确认身份</p><pre><code>from fastapi import FastAPI, Dependsfrom fastapi.security import HTTPBasic, HTTPBasicCredentialsimport uvicornapp = FastAPI()security = HTTPBasic()@app.get(&quot;/index&quot;)async def index(credentials: HTTPBasicCredentials = Depends(security)):    return {&quot;username&quot;: credentials.username, &quot;password&quot;: credentials.password}</code></pre><p>当用户访问 /index 的时候，会提示输入用户名和密码：</p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/dvlvakm1DFPw2BLV/3291b0841ffd47239b6543f1f0c3d3771684.png" alt="image"> </p><p>输入完毕之后，信息会保存在 credentials，我们可以获取出来进行验证。</p><h3 id="6-5-其他"><a href="#6-5-其他" class="headerlink" title="6.5 其他"></a>6.5 其他</h3><h4 id="6-5-1-使用枚举"><a href="#6-5-1-使用枚举" class="headerlink" title="6.5.1 使用枚举"></a>6.5.1 使用枚举</h4><p>如果我们希望有一个参数的取值范围只能是固定的 几个值, 可以使用枚举类型</p><p>示例如下:</p><pre><code>from enum import Enumclass Gander(str, Enum):    type1 = &quot;boy&quot;        # 这里 type1 只是一个随意变量, 没有任何其他含义    type2 = &quot;girl&quot;@app.get(&quot;/users/{gander_type}&quot;)async def get_user(gander_type: Gander):    return {&quot;gander_type&quot;: gander_type}    # 这里的 gander_type 就只能是 boy/girl; 否则就会抛错</code></pre><h4 id="6-5-2-bool-类型自动转换"><a href="#6-5-2-bool-类型自动转换" class="headerlink" title="6.5.2 bool 类型自动转换"></a>6.5.2 bool 类型自动转换</h4><p>对于布尔类型，FastAPI 支持自动转换</p><pre><code>@app.get(&quot;/{flag}&quot;)async def get_flag(flag: bool):    return {&quot;flag&quot;: flag}        # 这里 flag 为 True/true/on/yes/1 均会转换为 True; 0/False/false/off/no 均会转为 False</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supervisor进程管理工具</title>
      <link href="/2021/10/18/supervisor/"/>
      <url>/2021/10/18/supervisor/</url>
      
        <content type="html"><![CDATA[<h2 id="一、supervisor简介"><a href="#一、supervisor简介" class="headerlink" title="一、supervisor简介"></a>一、supervisor简介</h2><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p><h2 id="二、安装supervisor"><a href="#二、安装supervisor" class="headerlink" title="二、安装supervisor"></a>二、安装supervisor</h2><ol><li>使用yum安装，在配好yum源之后，可以直接安装<pre class="line-numbers language-shell"><code class="language-shell">yum install supervisor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>pip 安装<pre class="line-numbers language-shell"><code class="language-shell">pip install supervisor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="三、生成supervisor配置文件"><a href="#三、生成supervisor配置文件" class="headerlink" title="三、生成supervisor配置文件"></a>三、生成supervisor配置文件</h2><p><strong>supervisor配置文件</strong><br>运行命令<code>echo_supervisord_conf</code>生成supervisor的初始配置文件:</p><pre class="line-numbers language-shell"><code class="language-shell">echo_supervisord_conf > /etc/supervisord.conf # 生成在哪个地方可以自己选择<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。</em></p><p><strong>supervisor子进程配置文件</strong><br>需要修改配置文件<code>files</code>字段的路径(子进程配置文件路径)</p><pre class="line-numbers language-shell"><code class="language-shell">...;[include]files = /etc/supervisord.d/*.ini # 子进程配置文件路径, 需要手动创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>默认子进程配置文件为ini格式，可在supervisor主配置文件中修改。</em></p><h2 id="四、supervisor配置文件的说明"><a href="#四、supervisor配置文件的说明" class="headerlink" title="四、supervisor配置文件的说明"></a>四、supervisor配置文件的说明</h2><h4 id="supervisor-conf配置文件说明："><a href="#supervisor-conf配置文件说明：" class="headerlink" title="supervisor.conf配置文件说明："></a>supervisor.conf配置文件说明：</h4><pre class="line-numbers language-shell"><code class="language-shell">[unix_http_server]file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用;chmod=0700                 ;socket文件的mode，默认是0700;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid;[inet_http_server]         ;HTTP服务器，提供web管理界面;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性;username=user              ;登录管理后台的用户名;password=123               ;登录管理后台的密码[supervisord]logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份loglevel=info                ;日志级别，默认info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ;pid 文件nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024minprocs=200                 ;可以打开的进程数的最小值，默认 200[supervisorctl]serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord; [program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令autostart=true       ; 在supervisord启动的时候也自动启动startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3       ; 启动失败自动重试次数，默认是3user=tomcat          ; 用哪个用户启动进程，默认是rootpriority=999         ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outstopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程;包含其它配置文件[include]files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="子进程配置文件说明："><a href="#子进程配置文件说明：" class="headerlink" title="子进程配置文件说明："></a>子进程配置文件说明：</h4><p>给需要管理的子进程(程序)编写一个配置文件，放在/etc/supervisor.d/目录下，以.ini作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（/etc/supervisord.d/test.conf）：</p><pre class="line-numbers language-shell"><code class="language-shell">#项目名[program:blog]#脚本目录directory=/opt/bin#脚本执行命令command=/usr/bin/python /opt/bin/test.py#supervisor启动的时候是否随着同时启动，默认Trueautostart=true#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的autorestart=false#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1startsecs=1#脚本运行的用户身份 user = test#日志输出 stderr_logfile=/tmp/blog_stderr.log stdout_logfile=/tmp/blog_stdout.log #把stderr重定向到stdout，默认 falseredirect_stderr = true#stdout日志文件大小，默认 50MBstdout_logfile_maxbytes = 20M#stdout日志文件备份数stdout_logfile_backups = 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="子进程配置示例"><a href="#子进程配置示例" class="headerlink" title="子进程配置示例"></a>子进程配置示例</h4><pre class="line-numbers language-shell"><code class="language-shell">#说明同上[program:test] directory=/opt/bin command=/opt/bin/testautostart=true autorestart=false stderr_logfile=/tmp/test_stderr.log stdout_logfile=/tmp/test_stdout.log #user = test  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、supervisor命令说明"><a href="#五、supervisor命令说明" class="headerlink" title="五、supervisor命令说明"></a>五、supervisor命令说明</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre class="line-numbers language-shell"><code class="language-shell">supervisorctl status        //查看所有进程的状态supervisorctl stop es       //停止essupervisorctl start es      //启动essupervisorctl restart       //重启essupervisorctl update        //配置文件修改后使用该命令加载新的配置supervisorctl reload        //重新启动配置中的所有程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>注：把<code>es</code>换成<code>all</code>可以管理配置中的所有进程。直接输入<code>supervisorctl</code>进入<code>supervisorctl</code>的shell交互界面，此时上面的命令不带<code>supervisorctl</code>可直接使用。</em></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用<code>supervisor</code>进程管理命令之前先启动<code>supervisord</code>，否则程序报错。<br>使用命令<code>supervisord -c /etc/supervisord.conf</code>启动。<br>若是<code>centos7</code>：</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl start supervisord.service     //启动supervisor并加载默认配置文件systemctl enable supervisord.service    //将supervisor加入开机启动项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 存储emoji 表情</title>
      <link href="/2021/10/13/mysql-save-emoji/"/>
      <url>/2021/10/13/mysql-save-emoji/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql-存储emoji-表情"><a href="#mysql-存储emoji-表情" class="headerlink" title="mysql 存储emoji 表情"></a>mysql 存储emoji 表情</h3><blockquote><p>近期订单模块发现奇怪bug，某个客户的订单一直更新不到系统中; 于是发现客户的订单号竟然有表情(🐝)…..真的奇葩;<br>特殊表情字符无法入库，而订单相关表设计的字符集为utf8，不支持特殊字符。存储emoji表情需要unicode字符集, 所以修改相关字符集, 得以解决。</p></blockquote><p><img src="./mysql_emoji.png" alt="mysql_emoji"></p><ol><li><p>需要将mysql 连接指定字符集utf8mb4<br> <code>mysql+mysqldb://user:pwd@localhost/database?charset=utf8mb4</code></p></li><li><p>数据库字符集 首先查看字符集设置如下, character_set_system为utf8, 需要将其修改为utf8mb4<br> 查看命令： <code>SHOW VARIABLES WHERE Variable_name LIKE &#39;character\_set\_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</code></p><pre><code> +--------------------------+--------------------+ | Variable_name            | Value              | +--------------------------+--------------------+ | character_set_client     | utf8mb4            | | character_set_connection | utf8mb4            | | character_set_database   | utf8mb4            | | character_set_filesystem | binary             | | character_set_results    | utf8mb4            | | character_set_server     | utf8mb4            | | character_set_system     | utf8               | | collation_connection     | utf8mb4_unicode_ci | | collation_database       | utf8mb4_unicode_ci | | collation_server         | utf8mb4_unicode_ci | +--------------------------+--------------------+</code></pre></li><li><p>改库、表、字段的字符集</p><pre class="line-numbers language-sql"><code class="language-sql"> <span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> database_name <span class="token keyword">CHARACTER SET</span> <span class="token operator">=</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci<span class="token punctuation">;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">CONVERT</span> <span class="token keyword">TO</span> <span class="token keyword">CHARACTER SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci<span class="token punctuation">;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name CHANGE column_name column_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">191</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pod假死</title>
      <link href="/2021/10/08/pod-jia-si/"/>
      <url>/2021/10/08/pod-jia-si/</url>
      
        <content type="html"><![CDATA[<h2 id="K8S-pod假死处理方案"><a href="#K8S-pod假死处理方案" class="headerlink" title="K8S pod假死处理方案"></a>K8S pod假死处理方案</h2><p>近期在调研新技术方案, 开发和灰度过程中遇到pod假死问题; 总结出两个方案, 可供参考.<br>详细内容: <a href="https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/guide/configure-liveness-readiness-probes.html</a></p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>pod在运行一段时间, 出现pod假死; 假死之后流量还是会正常打入到该pod, 无法处理这部分请求, 体现在API接口上就是大量504超时.</p><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>添加pod健康检查, 探测方式：exec方式, http探测, tcp探测; 可自行根据服务添加合理方式.<br>示例http探测方式:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>    <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthy        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5  </span><span class="token comment" spellcheck="true"># 容器启动 5s 之后开始执行 Liveness 探测</span>    <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5  </span><span class="token comment" spellcheck="true"># 每 5s 探测一次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>kafka消费异常, 某个pod消费能力不足(原因有许多, 比如代码需优化, 消息内容大, DB压力大等…), 导致rebalance, 从而同一个消费者组内的其他pod也rebalance, 数次之后, 出现pod假死, 表现为消息不消费, 观察pod无日志输出.</p><h4 id="处理方法-1"><a href="#处理方法-1" class="headerlink" title="处理方法"></a>处理方法</h4><p>添加生命探测, 与上面差不多.</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>    <span class="token key atrule">exec</span><span class="token punctuation">:</span>      <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /bin/bash    <span class="token punctuation">-</span> probe.sh    <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>    <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">6</span>    <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>probe.sh</p><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashoutputfile=./health_checkecho "OK" > ${outputfile}result=$(cat ${outputfile})if [[ "${result}" == "OK" ]]then    # sleep 10s    sleep 1s    rm -rf ${outputfile}    exit 0else    exit 1fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSGI和AWSGI</title>
      <link href="/2021/09/27/wsgi-he-awsgi/"/>
      <url>/2021/09/27/wsgi-he-awsgi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是WSGI？"><a href="#什么是WSGI？" class="headerlink" title="什么是WSGI？"></a>什么是WSGI？</h1><p>WSGI全称Web Server Gateway Interface(Web服务器网关接口)，这是一个规范（标准）；规定了web server如何与web application交互，application如何处理请求。</p><h2 id="WSGI不足"><a href="#WSGI不足" class="headerlink" title="WSGI不足"></a>WSGI不足</h2><ol><li>WSGI应用是单一的、同步的可调用对象（即输入一个请求，返回一个响应）。这个模式无法支持长连接或者Websocket这样的连接（有些WSGI server，比如Gunicorn里是能保持长连接，1-5s，但也仅限于他们的异步模式）。</li><li>即使我们使应用程序可以异步调用，但他也只能处理单路径，它也无法处理一些协议的多个数据传入事件，比如websocket frames（请求多路复用把一个消息分成了多个块，一个连接会有不同路径的消息交错，类似http2/3）。</li></ol><h1 id="ASGI"><a href="#ASGI" class="headerlink" title="ASGI"></a>ASGI</h1><p>ASGI全称Asynchronous  Server Gateway Interface(异步服务器网关接口)，他是构建与WSGI规范之上的，是WSGI的延伸和扩展。<br>ASGI尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意时候、被任意应用进程发送和接受的抽象。还采用了将ASGI协议转换为python兼容、异步友好的消息集的原则，具体为两部分：一个用于通信的标准化接口，通过实现它来构建服务器，以及一组用于每个web协议的标准消息格式。</p><h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><ul><li>WSGI和ASGI，都是基于Python设计的网关接口（Gateway Interface，GI）。</li><li>WSGI是基于http协议模式开发的，为同步应用程序提供标准，不支持Websocket。</li><li>ASGI是为异步、同步应用程序提供标准，支持WSGI不支持当前Web开发中的一些新的协议标准。</li><li>ASGI支持原有模式和Websocket的扩展，即ASGI是WSGI的扩展。</li></ul><p>WSGI服务器: uWSGI<br>WSGI框架: Flask1.0、Django3.0之前</p><p>AWSGI服务器: uvicorn<br>AWSGI框架：FastAPI、Django3.0之后、Flask2.0</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HomeBrew 安装</title>
      <link href="/2021/09/14/homebrew/"/>
      <url>/2021/09/14/homebrew/</url>
      
        <content type="html"><![CDATA[<h3 id="homebrew-国内飞速安装"><a href="#homebrew-国内飞速安装" class="headerlink" title="homebrew(国内飞速安装)"></a><code>homebrew</code>(国内飞速安装)</h3><p><code>homebrew</code>官网推荐的命令在国内巨慢…，不管你是否FQ，都没啥速度的提升</p><pre class="line-numbers language-sh"><code class="language-sh">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有个国内的源，可以使你下载速度提升百倍～</p><pre class="line-numbers language-sh"><code class="language-sh">/usr/bin/ruby -e "$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>若出现一下情况：</em></p><p>如果命令执行中卡在下面信息：</p><pre class="line-numbers language-sh"><code class="language-sh">==> Tapping homebrew/coreCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请<code>Command + C</code>中断脚本执行如下命令：</p><pre class="line-numbers language-sh"><code class="language-sh">cd "$(brew --repo)/Library/Taps/"mkdir homebrew && cd homebrewgit clone git://mirrors.ustc.edu.cn/homebrew-core.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>成功执行之后继续执行前文的安装命令。<br>最后看到<code>==&gt; Installation successful!</code>就说明安装成功了。</p><p>最最后执行：<code>brew update</code></p><p><code>cask</code>同样也有首次下载缓慢的问题，解决方法大致同上：</p><pre class="line-numbers language-sh"><code class="language-sh">cd "$(brew --repo)/Library/Taps/"cd homebrewgit clone https://mirrors.ustc.edu.cn/homebrew-cask.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>使用官方脚本同样会遇到uninstall地址无法访问问题，可以替换为下面脚本：</p><pre class="line-numbers language-sh"><code class="language-sh">/usr/bin/ruby -e "$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置国内镜像源"><a href="#设置国内镜像源" class="headerlink" title="设置国内镜像源"></a>设置国内镜像源</h3><p><code>brew、homebrew/core</code>是必备项目，<code>homebrew/cask</code>、<code>homebrew/bottles</code>按需设置。<br>通过<code>brew config</code>命令查看配置信息。</p><p><em>中科大源</em></p><pre class="line-numbers language-sh"><code class="language-sh">git -C "$(brew --repo)" remote set-url origin https://mirrors.ustc.edu.cn/brew.gitgit -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.gitgit -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.gitbrew update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恢复官方镜像源"><a href="#恢复官方镜像源" class="headerlink" title="恢复官方镜像源"></a>恢复官方镜像源</h3><pre class="line-numbers language-sh"><code class="language-sh">git -C "$(brew --repo)" remote set-url origin https://github.com/Homebrew/brew.gitgit -C "$(brew --repo homebrew/core)" remote set-url origin https://github.com/Homebrew/homebrew-core.gitgit -C "$(brew --repo homebrew/cask)" remote set-url origin https://github.com/Homebrew/homebrew-cask.gitbrew update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>homebrew-bottles</code>配置只能手动删除，将<code>~/.bash_profile</code>文件中的 <code>HOMEBREW_BOTTLE_DOMAIN=https://mirrors.xxx.com</code>内容删除，并执行<code>source ~/.bash_profile</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.k8s资源管理</title>
      <link href="/2021/09/07/04k8s/"/>
      <url>/2021/09/07/04k8s/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s资源管理"><a href="#k8s资源管理" class="headerlink" title="k8s资源管理"></a>k8s资源管理</h1><h2 id="资源管理介绍"><a href="#资源管理介绍" class="headerlink" title="资源管理介绍"></a>资源管理介绍</h2><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p><blockquote><p>​    kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p><p>​    kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p><p>​    Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p><p>​    当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p></blockquote><p><img src="./image-20200406225334627.png" alt="资源管理"></p><blockquote><p> 学习kubernetes的核心，就是学习如何对集群上的<code>Pod、Pod控制器、Service、存储</code>等各种资源进行操作</p></blockquote><h2 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h2><ul><li><p>命令式对象管理：直接使用命令去操作kubernetes资源</p><p><code>kubectl run nginx-pod --image=nginx:1.17.1 --port=80</code></p></li><li><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</p><p><code>kubectl create/patch -f nginx-pod.yaml</code></p></li><li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</p><p><code>kubectl apply -f nginx-pod.yaml</code></p></li></ul><table><thead><tr><th>类型</th><th>操作对象</th><th>适用环境</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>命令式对象管理</td><td>对象</td><td>测试</td><td>简单</td><td>只能操作活动对象，无法审计、跟踪</td></tr><tr><td>命令式对象配置</td><td>文件</td><td>开发</td><td>可以审计、跟踪</td><td>项目大时，配置文件多，操作麻烦</td></tr><tr><td>声明式对象配置</td><td>目录</td><td>开发</td><td>支持目录操作</td><td>意外情况下难以调试</td></tr></tbody></table><h3 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h3><p><strong>kubectl命令</strong></p><p>​    kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p><pre class="line-numbers language-md"><code class="language-md">kubectl [command] [type] [name] [flags]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p><p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p><p><strong>name</strong>：指定资源的名称，名称大小写敏感</p><p><strong>flags</strong>：指定额外的可选参数</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 查看所有pod</span>kubectl get pod <span class="token comment" spellcheck="true"># 查看某个pod</span>kubectl get pod pod_name<span class="token comment" spellcheck="true"># 查看某个pod,以yaml格式展示结果</span>kubectl get pod pod_name <span class="token operator">-</span>o yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>资源类型</strong></p><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p><pre class="line-numbers language-powershell"><code class="language-powershell">kubectl api<span class="token operator">-</span>resources<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经常使用的资源有下面这些：</p><table>    <tr>        <th>资源分类</th>        <th>资源名称</th>        <th>缩写</th>        <th>资源作用</th>    </tr>    <tr>        <td rowspan="2">集群级别资源</td>        <td>nodes</td>        <td>no</td>        <td>集群组成部分</td>    </tr>    <tr>        <td>namespaces</td>        <td>ns</td>        <td>隔离Pod</td>    </tr>    <tr>        <td>pod资源</td>        <td>pods</td>        <td>po</td>        <td>装载容器</td>    </tr>    <tr>        <td rowspan="8">pod资源控制器</td>        <td>replicationcontrollers</td>        <td>rc</td>        <td>控制pod资源</td>    </tr>    <tr>        <td>replicasets</td>        <td>rs</td>        <td>控制pod资源</td>    </tr>    <tr>        <td>deployments</td>        <td>deploy</td>        <td>控制pod资源</td>    </tr>    <tr>        <td>daemonsets</td>        <td>ds</td>        <td>控制pod资源</td>    </tr>    <tr>        <td>jobs</td>        <td></td>        <td>控制pod资源</td>    </tr>        <tr>        <td>cronjobs</td>        <td>cj</td>        <td>控制pod资源</td>    </tr>        <tr>        <td>horizontalpodautoscalers</td>        <td>hpa</td>        <td>控制pod资源</td>    </tr>        <tr>        <td>statefulsets</td>        <td>sts</td>        <td>控制pod资源</td>    </tr>    <tr>        <td rowspan="2">服务发现资源</td>        <td>services</td>        <td>svc</td>        <td>统一pod对外接口</td>    </tr>    <tr>        <td>ingress</td>        <td>ing</td>        <td>统一pod对外接口</td>    </tr>    <tr>        <td rowspan="3">存储资源</td>        <td>volumeattachments</td>        <td></td>        <td>存储</td>    </tr>    <tr>        <td>persistentvolumes</td>        <td>pv</td>        <td>存储</td>    </tr>    <tr>        <td>persistentvolumeclaims</td>        <td>pvc</td>        <td>存储</td>    </tr>    <tr>        <td rowspan="2">配置资源</td>        <td>configmaps</td>        <td>cm</td>        <td>配置</td>    </tr>    <tr>        <td>secrets</td>        <td></td>        <td>配置</td>    </tr></table><p><strong>操作</strong></p><p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p><pre class="line-numbers language-powershell"><code class="language-powershell">kubectl <span class="token operator">--</span>help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经常使用的操作有下面这些：</p><table>    <tr>        <th>命令分类</th>        <th>命令</th>        <th>翻译</th>        <th>命令作用</th>    </tr>    <tr>        <td rowspan="6">基本命令</td>        <td>create</td>        <td>创建</td>        <td>创建一个资源</td>    </tr>    <tr>        <td>edit</td>        <td>编辑</td>        <td>编辑一个资源</td>    </tr>    <tr>        <td>get</td>        <td>获取</td>        <td>获取一个资源</td>    </tr>   <tr>        <td>patch</td>        <td>更新</td>        <td>更新一个资源</td>    </tr>    <tr>        <td>delete</td>        <td>删除</td>        <td>删除一个资源</td>    </tr>    <tr>        <td>explain</td>        <td>解释</td>        <td>展示资源文档</td>    </tr>    <tr>        <td rowspan="10">运行和调试</td>        <td>run</td>        <td>运行</td>        <td>在集群中运行一个指定的镜像</td>    </tr>    <tr>        <td>expose</td>        <td>暴露</td>        <td>暴露资源为Service</td>    </tr>    <tr>        <td>describe</td>        <td>描述</td>        <td>显示资源内部信息</td>    </tr>    <tr>        <td>logs</td>        <td>日志</td>        <td>输出容器在 pod 中的日志</td>    </tr>        <tr>        <td>attach</td>        <td>缠绕</td>        <td>进入运行中的容器</td>    </tr>        <tr>        <td>exec</td>        <td>执行</td>        <td>执行容器中的一个命令</td>    </tr>        <tr>        <td>cp</td>        <td>复制</td>        <td>在Pod内外复制文件</td>    </tr>        <tr>        <td>rollout</td>        <td>首次展示</td>        <td>管理资源的发布</td>    </tr>    <tr>        <td>scale</td>        <td>规模</td>        <td>扩(缩)容Pod的数量</td>    </tr>    <tr>        <td>autoscale</td>        <td>自动调整</td>        <td>自动调整Pod的数量</td>    </tr>    <tr>        <td rowspan="2">高级命令</td>        <td>apply</td>        <td>rc</td>        <td>通过文件对资源进行配置</td>    </tr>    <tr>        <td>label</td>        <td>标签</td>        <td>更新资源上的标签</td>    </tr>    <tr>        <td rowspan="2">其他命令</td>        <td>cluster-info</td>        <td>集群信息</td>        <td>显示集群信息</td>    </tr>    <tr>        <td>version</td>        <td>版本</td>        <td>显示当前Server和Client的版本</td>    </tr></table><p>下面以一个namespace / pod的创建和删除简单演示下命令的使用：</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 创建一个namespace</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl create namespace dev</span>namespace<span class="token operator">/</span>dev created<span class="token comment" spellcheck="true"># 获取namespace</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl get ns</span>NAME              STATUS   AGEdefault           Active   21hdev               Active   21skube<span class="token operator">-</span>node<span class="token operator">-</span>lease   Active   21hkube<span class="token operator">-</span>public       Active   21hkube<span class="token operator">-</span>system       Active   21h<span class="token comment" spellcheck="true"># 在此namespace下创建并运行一个nginx的Pod</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl run pod --image=nginx -n dev</span>kubectl run <span class="token operator">--</span>generator=deployment<span class="token operator">/</span>apps<span class="token punctuation">.</span>v1 is DEPRECATED and will be removed in a future version<span class="token punctuation">.</span> Use kubectl run <span class="token operator">--</span>generator=run<span class="token operator">-</span>pod<span class="token operator">/</span>v1 or kubectl create instead<span class="token punctuation">.</span>deployment<span class="token punctuation">.</span>apps<span class="token operator">/</span>pod created<span class="token comment" spellcheck="true"># 查看新创建的pod</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl get pod -n dev</span>NAME                   READY   STATUS    RESTARTS   AGEpod<span class="token operator">-</span>864f9875b9<span class="token operator">-</span>pcw7x   1<span class="token operator">/</span>1     Running   0          21s<span class="token comment" spellcheck="true"># 删除指定的pod</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl delete pod pod-864f9875b9-pcw7x</span>pod <span class="token string">"pod-864f9875b9-pcw7x"</span> deleted<span class="token comment" spellcheck="true"># 删除指定的namespace</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl delete ns dev</span>namespace <span class="token string">"dev"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p><p>1） 创建一个nginxpod.yaml，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dev<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginxpod  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> dev<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>containers    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.17.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）执行create命令，创建资源：</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl create -f nginxpod.yaml</span>namespace<span class="token operator">/</span>dev createdpod<span class="token operator">/</span>nginxpod created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时发现创建了两个资源对象，分别是namespace和pod</p><p>3）执行get命令，查看资源：</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true">#  kubectl get -f nginxpod.yaml</span>NAME            STATUS   AGEnamespace<span class="token operator">/</span>dev   Active   18sNAME            READY   STATUS    RESTARTS   AGEpod<span class="token operator">/</span>nginxpod    1<span class="token operator">/</span>1     Running   0          17s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就显示了两个资源对象的信息</p><p>4）执行delete命令，删除资源：</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true"># kubectl delete -f nginxpod.yaml</span>namespace <span class="token string">"dev"</span> deletedpod <span class="token string">"nginxpod"</span> deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时发现两个资源对象被删除了</p><pre class="line-numbers language-md"><code class="language-md">总结:    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 首先执行一次kubectl apply -f yaml文件，发现创建了资源</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true">#  kubectl apply -f nginxpod.yaml</span>namespace<span class="token operator">/</span>dev createdpod<span class="token operator">/</span>nginxpod created<span class="token comment" spellcheck="true"># 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span><span class="token namespace">[root@master ~]</span><span class="token comment" spellcheck="true">#  kubectl apply -f nginxpod.yaml</span>namespace<span class="token operator">/</span>dev unchangedpod<span class="token operator">/</span>nginxpod unchanged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-md"><code class="language-md">总结:    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）    使用apply操作资源：        如果资源不存在，就创建，相当于 kubectl create        如果资源已存在，就更新，相当于 kubectl patch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用推荐:  三种方式应该怎么用 ?</p></blockquote><p> 创建/更新资源      使用声明式对象配置 kubectl apply -f  XXX.yaml</p><p> 删除资源              使用命令式对象配置 kubectl delete -f  XXX.yaml</p><p> 查询资源              使用命令式对象管理 kubectl get(describe) 资源名称</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03. 安装minikube</title>
      <link href="/2021/08/04/03k8s/"/>
      <url>/2021/08/04/03k8s/</url>
      
        <content type="html"><![CDATA[<p>安装minikube的前提需要安装kubectl</p><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><h4 id="Centos、Readhat"><a href="#Centos、Readhat" class="headerlink" title="Centos、Readhat"></a>Centos、Readhat</h4><p>编辑yum 的kubenernetes源<br><code>vim /etc/yum.repos.d/kubernetes.repo</code><br>并输入下面的内容</p><pre><code>[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</code></pre><p>再使用命令:</p><pre><code>yum install -y kubectl</code></pre><h4 id="Ubuntu、Debian"><a href="#Ubuntu、Debian" class="headerlink" title="Ubuntu、Debian"></a>Ubuntu、Debian</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg <span class="token operator">|</span> apt-key add - <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">></span>/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF  <span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> -y kubelet kubeadm kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="MacOs"><a href="#MacOs" class="headerlink" title="MacOs"></a>MacOs</h4><pre class="line-numbers language-bash"><code class="language-bash">brew <span class="token function">install</span> kubernetes-clikubectl version --client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="安装minikube（使用阿里云镜像）"><a href="#安装minikube（使用阿里云镜像）" class="headerlink" title="安装minikube（使用阿里云镜像）"></a>安装minikube（使用阿里云镜像）</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><pre class="line-numbers language-bash"><code class="language-bash">curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.18.1/minikube-linux-amd64 <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x minikube <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">mv</span> minikube /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><pre class="line-numbers language-bash"><code class="language-bash">curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.18.1/minikube-linux-amd64 <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x minikube <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">mv</span> minikube /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动：<code>minikube start --registry-mirror=https://registry.docker-cn.com --image-mirror-country cn</code></p><p>完成以上步骤即可安装成功～</p><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>为了访问海外的资源，阿里云提供了一系列基础设施，请按照如下参数进行配置。其中常见参数</p><blockquote><p>–driver=xxx 从1.5.0版本开始，Minikube缺省使用本地最好的驱动来创建Kubernetes本地环境，测试过的版本 docker, kvm<br>–image-mirror-country cn 将缺省利用 registry.cn-hangzhou.aliyuncs.com/google_containers 作为安装Kubernetes的容器镜像仓库 （阿里云版本可选）<br>–iso-url=xxx  利用阿里云的镜像地址下载相应的 .iso 文件 （阿里云版本可选）<br>–registry-mirror=xxx 为了拉取Docker Hub镜像，需要为 Docker daemon 配置镜像加速，参考阿里云镜像服务<br>–cpus=2: 为minikube虚拟机分配CPU核数<br>–memory=2048mb: 为minikube虚拟机分配内存数<br>–kubernetes-version=xxx: minikube 虚拟机将使用的 kubernetes 版本</p></blockquote><ul><li><p>安装minikube，缺省驱动</p><p><code>minikube start --cpus=4 --memory=4096mb</code></p></li><li><p>安装minikube，Docker驱动</p><p><code>minikube start --driver=docker</code></p></li><li><p>安装minikube，KVM2驱动</p><p><code>minikube start --driver=kvm2</code></p></li><li><p>打开Kubernetes控制台</p><p><code>minikube dashboard</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02. Kubernetes 组件</title>
      <link href="/2021/07/26/02k8s/"/>
      <url>/2021/07/26/02k8s/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><p>一个Kubernetes集群由一组被称为节点的机器组成。这些节点上运行了Kubernetes所管理的容器化应用。kubernetes集群主要是由<strong>控制节点(master)</strong>、<strong>工作节点(node)</strong>构成。</p><p><img src="./components-of-kubernetes.svg" alt="kubernetes组件"></p><p><strong>master：集群的控制平面(Control Plane Components)，负责集群的决策(管理)</strong></p><blockquote><p><strong>kube-apiserver</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制<br><strong>kube-scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上<br><strong>kube-controller-manager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等<br>*<em>etcd *</em>： etcd 是兼具一致性和高可用性的键值数据库, 负责存储集群中各种资源对象的信息 </p></blockquote><p><strong>node：集群的数据平面，负责为容器提供运行环境(干活)</strong></p><blockquote><p><strong>kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器<br><strong>kube-proxy</strong> : 负责提供集群内部的服务发现和负载均衡<br><strong>Docker</strong> : 负责节点上容器的各种操作</p></blockquote><p><img src="./image-20200406184656917.png" alt="kubernetes系统各个组件调用关系"></p><p>简单介绍一下部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p><ol><li>kubernetes集群搭建好之后，master和node都会将自身所有相关信息存储到etcd数据库中。</li><li>nginx服务的安装请求会首先被发送到master节点的apiserver组件。</li><li>apiserver组件调用scheduler组件，scheduler组件来决定到底应该把这个服务安装到哪个node节点上。此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiserver。</li><li>apiserver调用controller-manager去调度node节点安装nginx服务。</li><li>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod，pod是kubernetes的最小操作单元，容器必须跑在pod中。</li><li>此时nginx服务就成功运行了，如果需要在集群外部访问该服务，就需要通过kube-proxy来对pod生成访问代理，这样，集群外部的用户就能访问集群中的nginx服务了。</li></ol><p><a href="https://kubernetes.io/zh/docs/concepts/overview/components/" target="_blank" rel="noopener">参考自 Kubernetes 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01. Kubernetes是什么?</title>
      <link href="/2021/07/21/01k8s/"/>
      <url>/2021/07/21/01k8s/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么?"></a>Kubernetes是什么?</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。 <strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p><h2 id="部署方式的演变"><a href="#部署方式的演变" class="headerlink" title="部署方式的演变"></a>部署方式的演变</h2><p><img src="./deploy_style.jpg" alt="deploy_style"></p><h4 id="传统部署"><a href="#传统部署" class="headerlink" title="传统部署"></a>传统部署</h4><blockquote><p>早期，直接将应用程序部署在物理机上。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。 </p></blockquote><h4 id="虚拟化部署"><a href="#虚拟化部署" class="headerlink" title="虚拟化部署"></a>虚拟化部署</h4><blockquote><p>可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境<br>优点：程序环境不会相互产生影响，提供了一定程度的安全性<br>缺点：增加了操作系统，浪费了部分资源</p></blockquote><h3 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h3><blockquote><p>容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p><p>容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：<br>​    可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等<br>​    运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦<br>​    容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></blockquote><h2 id="为什么需要-Kubernetes，它能做什么"><a href="#为什么需要-Kubernetes，它能做什么" class="headerlink" title="为什么需要 Kubernetes，它能做什么?"></a>为什么需要 Kubernetes，它能做什么?</h2><p>目前主流的方式是容器部署，在生产环节中假设一个容器发生故障，则需要启动另一个容器，并确保该容器不会停机等行为。这些问题就是由k8s来解决！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 </p><p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化！</p><p><strong>Kubernetes 为你提供：</strong></p><ul><li><p>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p>存储编排<br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p>自动部署和回滚</p><p>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p></li><li><p>自动完成装箱计算</p><p>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p>自我修复<br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p>密钥与配置管理</p><p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><p><strong>简单的总结：</strong></p><ul><li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li><li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li><li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li><li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li></ul><p><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener">参考自 Kubernetes 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CeontOS 安装oh-my-zsh</title>
      <link href="/2021/06/30/centosinstallohmyzsh/"/>
      <url>/2021/06/30/centosinstallohmyzsh/</url>
      
        <content type="html"><![CDATA[<h3 id="CeontOS-安装oh-my-zsh"><a href="#CeontOS-安装oh-my-zsh" class="headerlink" title="CeontOS 安装oh-my-zsh"></a>CeontOS 安装oh-my-zsh</h3><p>废话不多说，zsh配合oh-my-zsh体验相当nice，直接开干。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>安装zsh并切换zsh为默认shell</p><pre class="line-numbers language-sh"><code class="language-sh">yum install zsh -ychsh -s /bin/zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>安装oh-my-zsh(使用脚本安装)</p><pre class="line-numbers language-sh"><code class="language-sh">sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><strong>注意：如遇到网络问题可换下面这种方式</strong></p><ol start="3"><li>下载源码安装<pre class="line-numbers language-sh"><code class="language-sh">// 下载源码git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh// 复制配置cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>重新登录终端即可</li></ol><h4 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h4><p>直接下载到zsh插件目录下</p><pre class="line-numbers language-sh"><code class="language-sh">// 代码高量git clone https://github.com/zsh-users/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting// 命令自动补全git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑zsh配置：<code>vim ~/.zshrc</code> 搜索<code>plugins</code>，添加这两个插件即可</p><pre class="line-numbers language-sh"><code class="language-sh">plugins=(        git        zsh-autosuggestions        zsh-syntax-highlighting)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后<code>suorce ~/.zshrc</code></p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a> 这里大把的主题，可直接看到效果，可直接从这里选<br>找到想要的主题直接编辑zsh配置：<code>vim ~/.zshrc</code> 搜索<code>ZSH_THEME</code></p><pre class="line-numbers language-sh"><code class="language-sh">// 将这个值改成主题名即可，本人目前使用的主题如下ZSH_THEME="risto"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装完之后<code>conda</code>命令不能使用，在知道conda的路径情况下可直接使用命令<code>/home/user/miniconda3/bin/conda init zsh</code>即可</strong></p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab修改root密码</title>
      <link href="/2021/06/30/gitlabupdatepwd/"/>
      <url>/2021/06/30/gitlabupdatepwd/</url>
      
        <content type="html"><![CDATA[<h3 id="gitlab修改root密码"><a href="#gitlab修改root密码" class="headerlink" title="gitlab修改root密码"></a>gitlab修改root密码</h3><pre class="line-numbers language-sh"><code class="language-sh">gitlab-rails console -e production// 查询root用户> user = User.where(username:"root").first=> #<User id:1 @root>// 修改密码> user.password = "password"=> "password"// 保存> user.save!Enqueued ActionMailer::MailDeliveryJob (Job ID: 1baf8589-c259-4287-bb21-345c862c1935) to Sidekiq(mailers) with arguments: "DeviseMailer", "password_change", "deliver_now", {:args=>[#<GlobalID:0x00007f821c58df68 @uri=#<URI::GID gid://gitlab/User/1>>]}=> trueexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑集合</title>
      <link href="/2021/06/29/cai-keng-ji-he/"/>
      <url>/2021/06/29/cai-keng-ji-he/</url>
      
        <content type="html"><![CDATA[<h3 id="python文件操作"><a href="#python文件操作" class="headerlink" title="python文件操作"></a>python文件操作</h3><pre class="line-numbers language-python"><code class="language-python">os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 返回当前工作目录</span>os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归现实path路径下的所有文件和文件夹</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把路径分割成dirname和basename</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"./path1/path2/path3...."</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归的创建文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Python相关"><a href="#Python相关" class="headerlink" title="Python相关"></a>Python相关</h3><ul><li><p>MANIFEST.in文件<br>  参考: <a href="https://docs.python.org/2/distutils/sourcedist.html" target="_blank" rel="noopener">https://docs.python.org/2/distutils/sourcedist.html</a></p></li><li><p>python文件操作</p><pre class="line-numbers language-python"><code class="language-python">  os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 返回当前工作目录</span>os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归现实path路径下的所有文件和文件夹</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把路径分割成dirname和basename</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"./path1/path2/path3...."</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 递归的创建文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>pip 只下载不安装<br>  <code>pip download -d \home\packs -r requirement.txt</code></p></li><li><p>pip 安装:</p><pre class="line-numbers language-sh"><code class="language-sh">  pip install package --no-cache   --index-url https://pypi.tuna.tsinghua.edu.cn/simple   --extra-index-url https://ricequant:RiceQuant77@pypi.ricequant.com:8080/simple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>df.shift 值往后移动:</p><pre class="line-numbers language-python"><code class="language-python">  df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"Col1"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">"Col2"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">"Col3"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                index<span class="token operator">=</span>pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">"2020-01-01"</span><span class="token punctuation">,</span> <span class="token string">"2020-01-05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  df              Col1  Col2  Col3  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>    <span class="token number">10</span>    <span class="token number">13</span>    <span class="token number">17</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">02</span>    <span class="token number">20</span>    <span class="token number">23</span>    <span class="token number">27</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">03</span>    <span class="token number">15</span>    <span class="token number">18</span>    <span class="token number">22</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">04</span>    <span class="token number">30</span>    <span class="token number">33</span>    <span class="token number">37</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">05</span>    <span class="token number">45</span>    <span class="token number">48</span>    <span class="token number">52</span>  df<span class="token punctuation">.</span>shift<span class="token punctuation">(</span>periods<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>              Col1  Col2  Col3  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>   NaN   NaN   NaN  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">02</span>   NaN   NaN   NaN  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">03</span>   NaN   NaN   NaN  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">04</span>  <span class="token number">10.0</span>  <span class="token number">13.0</span>  <span class="token number">17.0</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">05</span>  <span class="token number">20.0</span>  <span class="token number">23.0</span>  <span class="token number">27.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>DF按照每分钟/每小时分组：</p><pre class="line-numbers language-python"><code class="language-python">  grp <span class="token operator">=</span> data<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span>by<span class="token operator">=</span><span class="token punctuation">[</span>data<span class="token punctuation">.</span>datetime_col<span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token punctuation">.</span>hour<span class="token punctuation">)</span><span class="token punctuation">,</span>                         data<span class="token punctuation">.</span>datetime_col<span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x<span class="token punctuation">.</span>minute<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="MySQL相关"><a href="#MySQL相关" class="headerlink" title="MySQL相关"></a>MySQL相关</h3><ul><li><p>MySQL远程连接:</p><ul><li>授权命令: <code>grant all privileges on *.* &#39;用户名&#39;@&#39;%&#39; identified by &#39;密码&#39; with grant option</code><br>%: 表示允许所有ip连接; 授权成功之后刷新一下权限表: <code>flush privileges</code><br>重启: <code>service mysql restart</code></li></ul></li><li><p>MySQL 用户/权限相关:</p><ul><li><p>创建用户:<br>  <code>create user &#39;user_name&#39;@&#39;host&#39; identified by &#39;password&#39;;</code></p></li><li><p>授权用户:<br>  <code>grant all privileges on database_name.tablename to &#39;user_name&#39;@&#39;host&#39;</code></p></li><li><p>权限:<br>  <code>select, insert, update, delete, all privileges</code></p></li><li><p>删除用户:<br>  <code>drop user &#39;user_name&#39;@&#39;host&#39;</code></p></li><li><p>设置与更改密码:<br>  <code>set password for &#39;username&#39;@&#39;host&#39;=PASSWORD(&#39;newpassword&#39;)</code><br>  如果是设置当前用户的密码：<br>  SET  PASSWORD = PASSWORD(‘newpassword’)<br>  如： SET  PASSWORD = PASSWORD(‘123456’)</p></li><li><p>撤销用户权限:<br>  <code>revoke privileges on database.tablename from &#39;username&#39;@&#39;host&#39;;</code></p></li></ul></li></ul><h3 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h3><ul><li><p>yum 只下载安装包到指定位置不安装<br>  <code>yum install lrzsz.x86_64 --downloadonly --downloaddir=/root/package</code></p></li><li><p>打开端口:<br>  <code>iptables -A INPUT -p tcp --dport 8080 -j ACCEPT</code></p></li><li><p>查看27017端口是否开启<br>  <code>firewall-cmd --query-port=27017/tcp</code></p></li><li><p>开启27017端口<br>  <code>firewall-cmd --zone=public --add-port=27017/tcp --permanent</code></p></li><li><p>重启防火墙<br>  <code>firewall-cmd --reload</code></p></li><li><p>MongoDB远程连接<br>  <code>mongo 192.168.199.129:27017</code></p></li><li><p>ps aux , 从ps中获取进程id, 并kill<br>  <code>kill $(ps aux | grep process_name | tr -s &#39; &#39;| cut -d &#39; &#39; -f 2)</code></p></li><li><p>查看pod使用的yaml文件<br>  <code>kubectl get pod pod_name -o yaml</code></p></li><li><p>git 相关</p><pre class="line-numbers language-sh"><code class="language-sh">  git tag 0.1    添加tag  git push origin [tag_name] 推送tag到远程仓库  git tag -d 0.1 删除本地tag版本  git push origin :refs/tags/0.1  删除远程tag版本  git reset --hard  版本号  git push -f       强制推送到远程  git stash         暂存本次改动  git stash pop     将暂存的取出  // git ssh默认端口变更，可使用这种方式  git remote add origin ssh://git@host:port/root/test_cicd.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>docker容器被kill掉，k8s中该节点的pod也被驱赶，因而使用以下命令查看被kill的所有进程<br>  <code>dmesg | grep -i -B100 &#39;killed process&#39;</code></p></li></ul><ul><li><p>修改github代理<br>  1.设置代理方法即可解决(请自行查找你的http代理端口)<br>  <code>git config --global http.proxy &quot;localhost:port&quot;</code></p><p>  2.完成后取消设置<br>  <code>git config --global --unset http.proxy</code></p></li></ul><ul><li><p>docker导入导出命令<br>  1.对镜像</p><pre class="line-numbers language-sh"><code class="language-sh">      // 导出      docker save -o file_name.tar      docker save > file_name.tar      // 导入      docker load -i file_name.tar      docker load < file_name.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.对容器</p><pre class="line-numbers language-sh"><code class="language-sh">      // 导出      docker export -o <file_name.tar> <container_name>      // 导入      docker import <file_name.tar> <container_name><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>授权某个用户root权限<br>  编辑文件：<code>/etc/sudoers</code> （需要权限）: <code>sudo vim /etc/sudoers</code><br>  找到这一行：<code>root    ALL=(ALL)       ALL</code><br>  添加一行：  <code>user    ALL=(ALL)       ALL</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compose 安装Gitlab和Gitrunner</title>
      <link href="/2021/06/12/gitlab-he-gitrunner-an-zhuang/"/>
      <url>/2021/06/12/gitlab-he-gitrunner-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>docker-compose.yaml</p></blockquote><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.5'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">gitlab</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> gitlab/gitlab<span class="token punctuation">-</span>ce<span class="token punctuation">:</span>latest    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> gitlab host    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">GITLAB_OMNIBUS_CONFIG</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">        gitlab_rails['gitlab_shell_ssh_port'] = 22</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8000:80"</span> <span class="token comment" spellcheck="true"># 网页端端口</span>      <span class="token punctuation">-</span> <span class="token string">"8822:22"</span> <span class="token comment" spellcheck="true"># ssh端口</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./config/gitlab<span class="token punctuation">:</span>/etc/gitlab      <span class="token punctuation">-</span> ./data/gitlab<span class="token punctuation">:</span>/var/opt/gitlab      <span class="token punctuation">-</span> ./logs<span class="token punctuation">:</span>/var/log/gitlab    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> gitlab  <span class="token key atrule">gitlab-runner</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> gitlab/gitlab<span class="token punctuation">-</span>runner<span class="token punctuation">:</span>alpine    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> gitlab    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 使用root权限</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./config/gitlab<span class="token punctuation">-</span>runner<span class="token punctuation">:</span>/etc/gitlab<span class="token punctuation">-</span>runner      <span class="token punctuation">-</span> /var/run/docker.sock<span class="token punctuation">:</span>/var/run/docker.sock <span class="token comment" spellcheck="true"># windows上宿主机docker.sock路径://var/run/docker.sock      linux上宿主机docker.sock路径:/var/run/docker.sock </span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> gitlab<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">gitlab</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>目录结构如下：</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">.├── config│   └── gitlab├── data│   └── gitlab|   └── gitlab-runner├── docker-compose.yaml└── logs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决 ERROR:Docker Got permission denied while trying to connect to the Docker daemon socket at unix://</strong></p><ol><li><p>给权限</p><pre class="line-numbers language-sh"><code class="language-sh">chmod 666 /var/run/docker.sock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>把当前用户加入docker组 </p><pre class="line-numbers language-sh"><code class="language-sh">sudo usermod -aG docker $USER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改docker服务配置/usr/lib/systemd/system/docker.service</p><pre class="line-numbers language-python"><code class="language-python">将原有的注释ExecStart<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>dockerd <span class="token operator">-</span>H fd<span class="token punctuation">:</span><span class="token operator">//</span> <span class="token operator">-</span><span class="token operator">-</span>containerd<span class="token operator">=</span><span class="token operator">/</span>run<span class="token operator">/</span>containerd<span class="token operator">/</span>containerd<span class="token punctuation">.</span>sock新加代码ExecStart<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>dockerd <span class="token operator">-</span>H unix<span class="token punctuation">:</span><span class="token operator">//</span><span class="token operator">/</span>var<span class="token operator">/</span>run<span class="token operator">/</span>docker<span class="token punctuation">.</span>sock <span class="token operator">-</span>H tcp<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">0.0</span><span class="token punctuation">:</span><span class="token number">2375</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重启docker服务</p><pre class="line-numbers language-sh"><code class="language-sh">systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="gitlab-runner-注册到gitlab"><a href="#gitlab-runner-注册到gitlab" class="headerlink" title="gitlab-runner 注册到gitlab"></a>gitlab-runner 注册到gitlab</h3><blockquote><p>注册命令</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">$ docker exec -it <gitlab-runner_container_name> gitlab-runner registerPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://gitlab.example.com/Please enter the gitlab-ci token for this runner:gitlab-token # gitlab项目里面的setting->CICD中 runner配置中Please enter the gitlab-ci description for this runner:[Double-dong.local]: gitlab-ci # 名字随便取Please enter the gitlab-ci tags for this runner (comma separated):python3.4 # 标签名， 后续在.gitlab-ci.yml中使用Registering runner... succeeded                     runner=6-uZ1ndZPlease enter the executor: docker+machine, kubernetes, ssh, virtualbox, docker-ssh, parallels, shell, docker-ssh+machine, custom, docker:docker # 这里选docker， 可根据需求任选一个Please enter the default Docker image (e.g. ruby:2.6):python:3.6 # 镜像名Runner registered successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="/medias/files/getlab-token.png">getlab-token</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Pypi Server</title>
      <link href="/2021/06/05/python-pypi-server/"/>
      <url>/2021/06/05/python-pypi-server/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Pypi-Server"><a href="#Python-Pypi-Server" class="headerlink" title="Python Pypi Server"></a>Python Pypi Server</h1><p><a href="https://www.jianshu.com/p/be91c70adb27" target="_blank" rel="noopener">转载自《PyPI打包上传实践》</a></p><h2 id="1-代码打包"><a href="#1-代码打包" class="headerlink" title="1. 代码打包"></a>1. 代码打包</h2><p>要打包代码，首先需要编写自己的代码包。比如你写了一个.py文件，里面有一些函数啥的，为了方便调用，你需要将代码打包，下次使用时直接调用就好，因此，第一步，将你写的代码打包。<br>创建一个文件夹，并在该文件夹下创建 <code>__init__.py</code> 文件，然后将你写的.py文件放到这个文件夹下面就行。</p><pre><code>packagename/    |    +-- __init__.py    |    +-- myfunction.py    |    +-- mymorefunction.py    |    +-- ...    |</code></pre><p><code>packagename</code>为你创建的包名称，<code>myxxx.py</code>是你写的python代码，还有添加个<code>__init__.py</code>文件（文件内容可以为空）.<br>现在你可以调用这个包了(引入包的路径)</p><pre><code>import packagename</code></pre><h2 id="2-符合pypi的格式"><a href="#2-符合pypi的格式" class="headerlink" title="2. 符合pypi的格式"></a>2. 符合pypi的格式</h2><p>将上面的文件的目录结构改成如下格式</p><pre><code>packagename    |    +-- COPYING.txt    |    +-- README.rst    |    +-- setup.py    |    +-- packagename    .       |    .       +-- __init__.py    .       |    .       +-- myscripts1.py    .       |    .       +-- mysscripts2.py    .       |    .       +-- mymorescripts.py    .       |    .    |    +-- docs/    |</code></pre><p>就是将原来的目录深移一层，文件夹的名称一样即可。在第一层目录下创建些特殊文件。<br><strong><em>Tips</em></strong></p><blockquote><ul><li>COPYING.txt :<strong><em>可以不要（节约时间，重要的事情先说、简单说）。</em></strong><br>就是授权文件，里面是你关于这个包的授权，比如：MIT license，那么你里面放入MIT License全文即可，当然，如果你不清楚这个，你完全可以不要这个文件。</li><li>README.rst：<strong><em>就是介绍，可以不要吧（不推荐，要是想让大家用的话还是好好写一写）</em></strong><br>这个文件想必研发都应该清楚。如果有，尽量放些东西在这里了，后面如果可能我们会用到它的。</li><li>setup.py：<strong><em>核心文件</em></strong><br>这里面的内容后面讲</li><li>docs/（这是个文件夹，存放一些文档的）<br>这个文件夹你放你的documents吧，不过要用心写文档真是个难事，所以这个文件夹基本是不存在的——为自己的懒惰可耻一把。</li></ul></blockquote><p><strong>setup.py</strong>的样例</p><pre><code># coding: utf-8import codecsimport osimport systry:    from setuptools import setupexcept:    from distutils.core import setup&quot;&quot;&quot;打包的用的setup必须引入，&quot;&quot;&quot;#!/usr/bin/env python# -*- coding: utf-8 -*-import sysif sys.version_info &lt; (2, 5):    sys.exit(&#39;Python 2.5 or greater is required.&#39;)try:    from setuptools import setupexcept ImportError:    from distutils.core import setupimport SendMoneywith open(&#39;README.rst&#39;, &#39;rb&#39;) as fp:    readme = fp.read()# 版本号，自己随便写VERSION = &quot;1.0.7&quot;LICENSE = &quot;MIT&quot;setup(    name=&#39;&lt;项目的名称&gt;&#39;,    version=VERSION,    description=(        &#39;&lt;项目的简单描述&gt;&#39;    ),    long_description=readme,    author=&#39;&lt;你的名字&gt;&#39;,    author_email=&#39;&lt;你的邮件地址&gt;&#39;,    maintainer=&#39;&lt;维护人员的名字&gt;&#39;,    maintainer_email=&#39;&lt;维护人员的邮件地址&#39;,    license=LICENSE,    packages=find_packages(),    platforms=[&quot;all&quot;],    url=&#39;&lt;项目的网址，我一般都是github的url&gt;&#39;,    install_requires=[        &quot;beautifulsoup4&quot;,        lxml_requirement        ],    classifiers=[        &#39;Development Status :: 4 - Beta&#39;,        &#39;Operating System :: OS Independent&#39;,        &#39;Intended Audience :: Developers&#39;,        &#39;License :: OSI Approved :: BSD License&#39;,        &#39;Programming Language :: Python&#39;,        &#39;Programming Language :: Python :: Implementation&#39;,        &#39;Programming Language :: Python :: 2&#39;,        &#39;Programming Language :: Python :: 2.7&#39;,        &#39;Programming Language :: Python :: 3&#39;,        &#39;Programming Language :: Python :: 3.4&#39;,        &#39;Programming Language :: Python :: 3.5&#39;,        &#39;Programming Language :: Python :: 3.6&#39;,        &#39;Topic :: Software Development :: Libraries&#39;    ],)# URL 你这个包的项目地址，如果有，给一个吧，没有你直接填写在PyPI你这个包的地址也是可以的# INSTALL_REQUIRES 模块所依赖的python模块# 以上字段不需要都包含</code></pre><p>文中的classifiers的内容并不是随便填写的，你需要参照本文参考文档中的PyPI Classifiers来写</p><h2 id="3、开始使用Distutils进行打包"><a href="#3、开始使用Distutils进行打包" class="headerlink" title="3、开始使用Distutils进行打包"></a>3、开始使用Distutils进行打包</h2><p>为了保证效果，在打包之前我们可以验证setup.py的正确性，执行下面的代码</p><blockquote><p>python setup.py check</p></blockquote><p>输出一般是running check<br>如果有错误或者警告，就会在此之后显示<br>没有任何显示表示Distutils认可你这个setup.py文件。</p><p>如果没有问题，那么就可以正式打包，执行下面的代码：</p><blockquote><p>python setup.py sdist</p></blockquote><p>执行完成后，会在顶层目录下生成dist目录和egg目录</p><p>打包完成后就可以准备将打包好的模块上传到pypi了，首先你需要在<a href="https://link.jianshu.com?t=https%3A%2F%2Fpypi.org%2F" target="_blank" rel="noopener">pypi</a>上进行注册<br>注册完成后，你需要在本地创建好pypi的配置文件，不然有可能会出现使用http无法上传到pypi的问题<br>在用户目录下创建.pypirc文件，文件的内容如下<br>window用户创建<code>.pypirc</code>可以命名为<code>.pypirc.</code>    位置示例：<code>C:\Users\admin\.pypirc.</code></p><pre><code>[distutils]index-servers=pypi[pypi]repository = https://upload.pypi.org/legacy/username = &lt;username&gt;password = &lt;password&gt;</code></pre><p>完成后运行：</p><blockquote><p>python setup.py register sdist upload</p></blockquote><p>最后出现<code>Server response (200): OK</code>就是成功了，可以去pypi上查看自己发布的包</p><p>包到这里，就完成了上传PyPI的工作了。你如果要用，安装下就好：</p><blockquote><p>pip install packagename</p></blockquote><p>这个过程还是很顺利的，以后多尝试，出现问题再补充！</p><p>作者：snowy_sunny<br>链接：<a href="https://www.jianshu.com/p/be91c70adb27" target="_blank" rel="noopener">https://www.jianshu.com/p/be91c70adb27</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pypi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx安装docker</title>
      <link href="/2021/05/26/liunx-an-zhuang-docker/"/>
      <url>/2021/05/26/liunx-an-zhuang-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="使用脚本自动安装-快速"><a href="#使用脚本自动安装-快速" class="headerlink" title="使用脚本自动安装(快速)"></a>使用脚本自动安装(快速)</h2><p>Linux 系统上可以使用这套脚本安装，另外可以通过 –mirror 选项使用国内源进行安装：<br><strong>获取脚本</strong><br><a href="/medias/files/get-docker.sh">get-docker.sh</a></p><p><strong>安装</strong></p><pre class="line-numbers language-sh"><code class="language-sh"># 记得给可执行权限chmod u+x get-docker.shsudo sh get-docker.sh --mirror Aliyun  # 使用阿里镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并安装好docker。</p><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><pre class="line-numbers language-sh"><code class="language-sh">sudo systemctl enable dockersudo systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p><p>建立 docker 组：</p><pre class="line-numbers language-sh"><code class="language-sh">sudo groupadd docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将当前用户加入 docker 组：</p><pre class="line-numbers language-sh"><code class="language-sh">sudo usermod -aG docker $USER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出当前终端并重新登录即可。</p><h2 id="使用国内镜像加速"><a href="#使用国内镜像加速" class="headerlink" title="使用国内镜像加速"></a>使用国内镜像加速</h2><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</em></p><p>重新启动服务</p><pre class="line-numbers language-sh"><code class="language-sh">sudo systemctl daemon-reloadsudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compose 安装Redis、Mysql、Kafka、RabbitMq</title>
      <link href="/2021/05/26/docker-compose-an-zhuang-redis-mysql-kafka-rabbitmq/"/>
      <url>/2021/05/26/docker-compose-an-zhuang-redis-mysql-kafka-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>docker-compose.yaml</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> redis    <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 容器内使用root权限</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./datadir<span class="token punctuation">:</span>/data      <span class="token punctuation">-</span> ./conf/redis.conf<span class="token punctuation">:</span>/usr/local/etc/redis/redis.conf      <span class="token punctuation">-</span> ./logs<span class="token punctuation">:</span>/logs    <span class="token key atrule">command</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#      两个写入操作 只是为了解决启动后警告 可以去掉</span>      /bin/bash <span class="token punctuation">-</span>c "echo 511 <span class="token punctuation">></span> /proc/sys/net/core/somaxconn      &amp;&amp; echo never <span class="token punctuation">></span> /sys/kernel/mm/transparent_hugepage/enabled      &amp;&amp; redis<span class="token punctuation">-</span>server /usr/local/etc/redis/redis.conf"    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 6379<span class="token punctuation">:</span><span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>redis.conf</p><pre class="line-numbers language-sh"><code class="language-sh">daemonize nopidfile /var/run/redis.pidport 6379bind 0.0.0.0timeout 0loglevel verboselogfile /logs/redis.logdatabases 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录结构如下：</p><pre><code>.├── conf│   └── redis.conf├── datadir├── docker-compose.yaml└── logs</code></pre><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>docker-compose.yaml</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>5.7.16    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./datadir<span class="token punctuation">:</span>/var/lib/mysql      <span class="token punctuation">-</span> ./conf/my.cnf<span class="token punctuation">:</span>/etc/my.cnf    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">"root"</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 3306<span class="token punctuation">:</span><span class="token number">3306</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>my.cnf</p><pre class="line-numbers language-sh"><code class="language-sh">[mysqld]user=mysqldefault-storage-engine=INNODBcharacter-set-client-handshake=FALSEcharacter-set-server=utf8mb4collation-server=utf8mb4_unicode_ciinit_connect='SET NAMES utf8mb4'[client]default-character-set=utf8mb4[mysql]default-character-set=utf8mb4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录结构如下：</p><pre><code>.├── conf│   └── my.cnf├── datadir└── docker-compose.yaml</code></pre><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>docker-compose.yaml</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">zookeeper</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> zookeeper    <span class="token key atrule">image</span><span class="token punctuation">:</span> wurstmeister/zookeeper    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./zookeeper/data<span class="token punctuation">:</span>/data    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"2181:2181"</span>  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka    <span class="token key atrule">image</span><span class="token punctuation">:</span> wurstmeister/kafka    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"9092:9092"</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">KAFKA_ADVERTISED_HOST_NAME</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">KAFKA_MESSAGE_MAX_BYTES</span><span class="token punctuation">:</span> <span class="token number">2000000</span>      <span class="token key atrule">KAFKA_CREATE_TOPICS</span><span class="token punctuation">:</span> <span class="token string">"test:1:1"</span>      <span class="token key atrule">KAFKA_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> zookeeper<span class="token punctuation">:</span><span class="token number">2181</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ./kafka<span class="token punctuation">:</span>/kafka  <span class="token key atrule">kafka-manager</span><span class="token punctuation">:</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka<span class="token punctuation">-</span>manager    <span class="token key atrule">image</span><span class="token punctuation">:</span> sheepkiller/kafka<span class="token punctuation">-</span>manager    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 9020<span class="token punctuation">:</span><span class="token number">9000</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">ZK_HOSTS</span><span class="token punctuation">:</span> zookeeper<span class="token punctuation">:</span><span class="token number">2181</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 目录结构如下： </p><pre><code>├── docker-compose.yaml├── kafka└── zookeeper    └── data</code></pre><h3 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h3><p>docker-compose.yaml</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.2"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">:</span>3<span class="token punctuation">-</span>management<span class="token punctuation">-</span>alpine    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> <span class="token string">'rabbitmq'</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> 5672<span class="token punctuation">:</span><span class="token number">5672</span>        <span class="token punctuation">-</span> 15672<span class="token punctuation">:</span><span class="token number">15672</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> ./data/<span class="token punctuation">:</span>/var/lib/rabbitmq/        <span class="token punctuation">-</span> ./log/<span class="token punctuation">:</span>/var/log/rabbitmq    <span class="token key atrule">networks</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> rabbitmq_go_net    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_VHOST=my_vhost      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_USER=admin      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_PASS=admin<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq_go_net</span><span class="token punctuation">:</span>  <span class="token key atrule">driver</span><span class="token punctuation">:</span> bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录结构如下：</p><pre class="line-numbers language-sh"><code class="language-sh">├── data├── docker-compose.yaml└── log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gunicorn 配置详解</title>
      <link href="/2021/05/16/gunicorn-pei-zhi-xiang-jie/"/>
      <url>/2021/05/16/gunicorn-pei-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p><code>-c CONFIG, --config CONFIG</code><br>Gunicorn配置文件路径，路径形式的字符串格式，如：</p><pre class="line-numbers language-sh"><code class="language-sh">gunicorn -c gunicorn.conf main:app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>-b ADDRESS, --bind ADDRESS</code><br>Gunicorn绑定服务器套接字，Host形式的字符串格式。Gunicorn可绑定多个套接字，如：</p><pre class="line-numbers language-sh"><code class="language-sh">gunicorn -b 127.0.0.1:8000 -b [::1]:9000 manager:app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h3><p><code>--backlog</code><br>未决连接的最大数量，即等待服务的客户的数量。必须是正整数，一般设定在64~2048的范围内，一般设置为2048，超过这个数字将导致客户端在尝试连接时错误</p><h3 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h3><p><code>-w INT, --workers INT</code><br>用于处理工作进程的数量，为正整数，默认为1。worker推荐的数量为当前的CPU个数*2 + 1。计算当前的CPU个数方法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing<span class="token keyword">print</span> multiprocessing<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="worker-class"><a href="#worker-class" class="headerlink" title="worker_class"></a>worker_class</h3><p><code>-k STRTING, --worker-class STRTING</code><br>使用寿命工作模式，默认为sync。可使用下面的常用的工作模式:</p><ul><li>sync</li><li>eventlet: 需要下载eventlet &gt;= 0.9.7</li><li>gevent: 需要下载gevent &gt;= 0.13</li><li>tornado: 需要下载tornado &gt;= 0.2</li><li>gthread</li><li>gaiohttp：需要python 3.4和aiohttp&gt;=0.21.5</li><li>uvicorn: 需要下载uvicorn(部署fastAPI时使用, 下面举个例子)</li></ul><pre class="line-numbers language-sh"><code class="language-sh"># 举个例子(fastAPI)gunicorn example:app -w 4 -k uvicorn.workers.UvicornWorker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="threads"><a href="#threads" class="headerlink" title="threads"></a>threads</h3><p><code>--threads INT</code><br>处理请求的工作线程数，使用指定数量的线程运行每个worker。为正整数，默认为1。</p><h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>--worker-connections INT</code><br>最大客户端并发数量，默认情况下这个值为1000。此设置将影响gevent和eventlet工作模式</p><h3 id="max-requests"><a href="#max-requests" class="headerlink" title="max_requests"></a>max_requests</h3><p><code>--max-requests INT</code><br>重新启动之前，工作将处理的最大请求数。默认值为0。</p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p><code>-t INT, --timeout INT</code><br>超过这么多秒后工作将被杀掉，并重新启动。一般设定为30秒</p><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p><code>--keep-alive INT</code><br>在keep-alive连接上等待请求的秒数，默认情况下值为2。一般设定在1~5秒之间。</p><h3 id="limit-request-line"><a href="#limit-request-line" class="headerlink" title="limit_request_line"></a>limit_request_line</h3><p><code>--limit-request-line INT</code><br>HTTP请求行的最大大小，此参数用于限制HTTP请求行的允许大小，默认情况下，这个值为4094。该值的范围为0~8190。此参数可以防止任何DDOS攻击</p><h3 id="limit-request-fields"><a href="#limit-request-fields" class="headerlink" title="limit_request_fields"></a>limit_request_fields</h3><p><code>--limit-request-fields INT</code><br>限制HTTP请求中请求头字段的数量。此字段用于限制请求头字段的数量以防止DDOS攻击，与limit-request-field-size一起使用可以提高安全性。默认情况下，这个值为100，这个值不能超过32768</p><h3 id="limit-request-field-size"><a href="#limit-request-field-size" class="headerlink" title="limit_request_field_size"></a>limit_request_field_size</h3><p><code>--limit-request-field-size INT</code><br>限制HTTP请求中请求头的大小，默认情况下这个值为8190。值是一个整数或者0，当该值为0时，表示将对请求头大小不做限制</p><h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><p><code>--reload</code><br>代码更新时将重启工作，默认为False。此设置一般用于开发，每当应用程序发生更改时，都会导致工作重新启动。</p><h3 id="reload-engine"><a href="#reload-engine" class="headerlink" title="reload_engine"></a>reload_engine</h3><p><code>--reload-engine STRTING</code><br>选择重载的引擎，支持的有三种：</p><ul><li>auto</li><li>pull</li><li>inotity：需要下载</li></ul><h3 id="check-config"><a href="#check-config" class="headerlink" title="check_config"></a>check_config</h3><p><code>--check-config</code><br>显示现在的配置，默认值为False，即显示。</p><h3 id="preload-app"><a href="#preload-app" class="headerlink" title="preload_app"></a>preload_app</h3><p><code>--preload</code><br>在工作进程被复制(派生)之前加载应用程序代码，默认为False。通过预加载应用程序，你可以节省RAM资源，并且加快服务器启动时间。</p><h3 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h3><p><code>--chdir</code><br>加载应用程序之前将chdir目录指定到指定目录</p><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p><code>--daemon</code><br>守护Gunicorn进程，默认False</p><h3 id="raw-env"><a href="#raw-env" class="headerlink" title="raw_env"></a>raw_env</h3><p><code>-e ENV, --env ENV</code><br>设置环境变量(key=value)，将变量传递给执行环境，如：</p><pre class="line-numbers language-sh"><code class="language-sh">gunicorin -b 127.0.0.1:8000 -e abc=123 manager:app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在配置文件中写法：</p><pre class="line-numbers language-sh"><code class="language-sh">raw_env=["abc=123"]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><p><code>-p FILE, --pid FILE</code><br>设置pid文件的文件名，如果不设置将不会创建pid文件</p><h3 id="worker-tmp-dir"><a href="#worker-tmp-dir" class="headerlink" title="worker_tmp_dir"></a>worker_tmp_dir</h3><p><code>--worker-tmp-dir DIR</code><br>设置工作临时文件目录，如果不设置会采用默认值。</p><h3 id="accesslog"><a href="#accesslog" class="headerlink" title="accesslog"></a>accesslog</h3><p><code>--access-logfile FILE</code><br>要写入的访问日志目录</p><h3 id="access-log-format"><a href="#access-log-format" class="headerlink" title="access_log_format"></a>access_log_format</h3><p><code>--access-logformat STRING</code><br>要写入的访问日志格式。如：</p><pre class="line-numbers language-sh"><code class="language-sh">access_log_format = '%(h)s %(l)s %(u)s %(t)s'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常见格式说明：<br>|  识别码   | 说明                          |<br>|  —-     | —-                           |<br>|  h        |远程地址                        |<br>|  l        |“-“                            |<br>|  u        |用户名                            |<br>|  t        |时间                            |<br>|  r        |状态行，如：GET /test HTTP/1.1    |<br>|  m        |请求方法                        |<br>|  U        |没有查询字符串的URL            |<br>|  q        |查询字符串                        |<br>|  H        |协议                            |<br>|  s        |状态码                            |<br>|  B        |response长度                    |<br>|  b        |response长度(CLF格式)            |<br>|  f        |参考                            |<br>|  a        |用户代理                        |<br>|  T        |请求时间，单位为s                |<br>|  D        |请求时间，单位为ms                 |<br>|  p        |进程id                            |<br>|  {Header}i    | 请求头                    |<br>|  {Header}o    | 相应头                    |<br>|  {Variable}e    | 环境变量                    |</p><h3 id="errorlog"><a href="#errorlog" class="headerlink" title="errorlog"></a>errorlog</h3><p><code>--error-logfile FILE, --log-file FILE</code><br>要写入错误日志的文件目录。</p><h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h3><p><code>--log-level LEVEL</code><br>错误日志输出等级。</p><p>支持的级别名称为:</p><ul><li>debug</li><li>info</li><li>warning</li><li>error</li><li>critical</li></ul><p>更多配置：<a href="http://docs.gunicorn.org/en/stable/settings.html#server-mechanics" target="_blank" rel="noopener">http://docs.gunicorn.org/en/stable/settings.html#server-mechanics</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
